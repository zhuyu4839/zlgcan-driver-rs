/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const TIME_UTC: u32 = 1;
pub const CAN_EFF_FLAG: u32 = 2147483648;
pub const CAN_RTR_FLAG: u32 = 1073741824;
pub const CAN_ERR_FLAG: u32 = 536870912;
pub const CAN_ID_FLAG: u32 = 536870911;
pub const CAN_SFF_MASK: u32 = 2047;
pub const CAN_EFF_MASK: u32 = 536870911;
pub const CAN_ERR_MASK: u32 = 536870911;
pub const CAN_SFF_ID_BITS: u32 = 11;
pub const CAN_EFF_ID_BITS: u32 = 29;
pub const CAN_MAX_DLC: u32 = 8;
pub const CAN_MAX_DLEN: u32 = 8;
pub const CANFD_MAX_DLC: u32 = 15;
pub const CANFD_MAX_DLEN: u32 = 64;
pub const TX_DELAY_SEND_FLAG: u32 = 128;
pub const TX_DELAY_SEND_TIME_UNIT_FLAG: u32 = 64;
pub const TX_ECHO_FLAG: u32 = 32;
pub const CANFD_BRS: u32 = 1;
pub const CANFD_ESI: u32 = 2;
pub const ZCAN_PCI5121: u32 = 1;
pub const ZCAN_PCI9810: u32 = 2;
pub const ZCAN_USBCAN1: u32 = 3;
pub const ZCAN_USBCAN2: u32 = 4;
pub const ZCAN_PCI9820: u32 = 5;
pub const ZCAN_CAN232: u32 = 6;
pub const ZCAN_PCI5110: u32 = 7;
pub const ZCAN_CANLITE: u32 = 8;
pub const ZCAN_ISA9620: u32 = 9;
pub const ZCAN_ISA5420: u32 = 10;
pub const ZCAN_PC104CAN: u32 = 11;
pub const ZCAN_CANETUDP: u32 = 12;
pub const ZCAN_CANETE: u32 = 12;
pub const ZCAN_DNP9810: u32 = 13;
pub const ZCAN_PCI9840: u32 = 14;
pub const ZCAN_PC104CAN2: u32 = 15;
pub const ZCAN_PCI9820I: u32 = 16;
pub const ZCAN_CANETTCP: u32 = 17;
pub const ZCAN_PCIE_9220: u32 = 18;
pub const ZCAN_PCI5010U: u32 = 19;
pub const ZCAN_USBCAN_E_U: u32 = 20;
pub const ZCAN_USBCAN_2E_U: u32 = 21;
pub const ZCAN_PCI5020U: u32 = 22;
pub const ZCAN_EG20T_CAN: u32 = 23;
pub const ZCAN_PCIE9221: u32 = 24;
pub const ZCAN_WIFICAN_TCP: u32 = 25;
pub const ZCAN_WIFICAN_UDP: u32 = 26;
pub const ZCAN_PCIe9120: u32 = 27;
pub const ZCAN_PCIe9110: u32 = 28;
pub const ZCAN_PCIe9140: u32 = 29;
pub const ZCAN_USBCAN_4E_U: u32 = 31;
pub const ZCAN_CANDTU_200UR: u32 = 32;
pub const ZCAN_CANDTU_MINI: u32 = 33;
pub const ZCAN_USBCAN_8E_U: u32 = 34;
pub const ZCAN_CANREPLAY: u32 = 35;
pub const ZCAN_CANDTU_NET: u32 = 36;
pub const ZCAN_CANDTU_100UR: u32 = 37;
pub const ZCAN_PCIE_CANFD_100U: u32 = 38;
pub const ZCAN_PCIE_CANFD_200U: u32 = 39;
pub const ZCAN_PCIE_CANFD_400U: u32 = 40;
pub const ZCAN_USBCANFD_200U: u32 = 41;
pub const ZCAN_USBCANFD_100U: u32 = 42;
pub const ZCAN_USBCANFD_MINI: u32 = 43;
pub const ZCAN_CANFDCOM_100IE: u32 = 44;
pub const ZCAN_CANSCOPE: u32 = 45;
pub const ZCAN_CLOUD: u32 = 46;
pub const ZCAN_CANDTU_NET_400: u32 = 47;
pub const ZCAN_CANFDNET_TCP: u32 = 48;
pub const ZCAN_CANFDNET_200U_TCP: u32 = 48;
pub const ZCAN_CANFDNET_UDP: u32 = 49;
pub const ZCAN_CANFDNET_200U_UDP: u32 = 49;
pub const ZCAN_CANFDWIFI_TCP: u32 = 50;
pub const ZCAN_CANFDWIFI_100U_TCP: u32 = 50;
pub const ZCAN_CANFDWIFI_UDP: u32 = 51;
pub const ZCAN_CANFDWIFI_100U_UDP: u32 = 51;
pub const ZCAN_CANFDNET_400U_TCP: u32 = 52;
pub const ZCAN_CANFDNET_400U_UDP: u32 = 53;
pub const ZCAN_CANFDBLUE_200U: u32 = 54;
pub const ZCAN_CANFDNET_100U_TCP: u32 = 55;
pub const ZCAN_CANFDNET_100U_UDP: u32 = 56;
pub const ZCAN_CANFDNET_800U_TCP: u32 = 57;
pub const ZCAN_CANFDNET_800U_UDP: u32 = 58;
pub const ZCAN_USBCANFD_800U: u32 = 59;
pub const ZCAN_PCIE_CANFD_100U_EX: u32 = 60;
pub const ZCAN_PCIE_CANFD_400U_EX: u32 = 61;
pub const ZCAN_PCIE_CANFD_200U_MINI: u32 = 62;
pub const ZCAN_PCIE_CANFD_200U_M2: u32 = 63;
pub const ZCAN_CANFDDTU_400_TCP: u32 = 64;
pub const ZCAN_CANFDDTU_400_UDP: u32 = 65;
pub const ZCAN_CANFDWIFI_200U_TCP: u32 = 66;
pub const ZCAN_CANFDWIFI_200U_UDP: u32 = 67;
pub const ZCAN_CANFDDTU_800ER_TCP: u32 = 68;
pub const ZCAN_CANFDDTU_800ER_UDP: u32 = 69;
pub const ZCAN_CANFDDTU_800EWGR_TCP: u32 = 70;
pub const ZCAN_CANFDDTU_800EWGR_UDP: u32 = 71;
pub const ZCAN_CANFDDTU_600EWGR_TCP: u32 = 72;
pub const ZCAN_CANFDDTU_600EWGR_UDP: u32 = 73;
pub const ZCAN_CANFDDTU_CASCADE_TCP: u32 = 74;
pub const ZCAN_CANFDDTU_CASCADE_UDP: u32 = 75;
pub const ZCAN_USBCANFD_400U: u32 = 76;
pub const ZCAN_CANFDDTU_200U: u32 = 77;
pub const ZCAN_ZPSCANFD_TCP: u32 = 78;
pub const ZCAN_ZPSCANFD_USB: u32 = 79;
pub const ZCAN_CANFDBRIDGE_PLUS: u32 = 80;
pub const ZCAN_OFFLINE_DEVICE: u32 = 98;
pub const ZCAN_VIRTUAL_DEVICE: u32 = 99;
pub const ZCAN_ERROR_CAN_OVERFLOW: u32 = 1;
pub const ZCAN_ERROR_CAN_ERRALARM: u32 = 2;
pub const ZCAN_ERROR_CAN_PASSIVE: u32 = 4;
pub const ZCAN_ERROR_CAN_LOSE: u32 = 8;
pub const ZCAN_ERROR_CAN_BUSERR: u32 = 16;
pub const ZCAN_ERROR_CAN_BUSOFF: u32 = 32;
pub const ZCAN_ERROR_CAN_BUFFER_OVERFLOW: u32 = 64;
pub const ZCAN_ERROR_DEVICEOPENED: u32 = 256;
pub const ZCAN_ERROR_DEVICEOPEN: u32 = 512;
pub const ZCAN_ERROR_DEVICENOTOPEN: u32 = 1024;
pub const ZCAN_ERROR_BUFFEROVERFLOW: u32 = 2048;
pub const ZCAN_ERROR_DEVICENOTEXIST: u32 = 4096;
pub const ZCAN_ERROR_LOADKERNELDLL: u32 = 8192;
pub const ZCAN_ERROR_CMDFAILED: u32 = 16384;
pub const ZCAN_ERROR_BUFFERCREATE: u32 = 32768;
pub const ZCAN_ERROR_CANETE_PORTOPENED: u32 = 65536;
pub const ZCAN_ERROR_CANETE_INDEXUSED: u32 = 131072;
pub const ZCAN_ERROR_REF_TYPE_ID: u32 = 196609;
pub const ZCAN_ERROR_CREATE_SOCKET: u32 = 196610;
pub const ZCAN_ERROR_OPEN_CONNECT: u32 = 196611;
pub const ZCAN_ERROR_NO_STARTUP: u32 = 196612;
pub const ZCAN_ERROR_NO_CONNECTED: u32 = 196613;
pub const ZCAN_ERROR_SEND_PARTIAL: u32 = 196614;
pub const ZCAN_ERROR_SEND_TOO_FAST: u32 = 196615;
pub const STATUS_ERR: u32 = 0;
pub const STATUS_OK: u32 = 1;
pub const STATUS_ONLINE: u32 = 2;
pub const STATUS_OFFLINE: u32 = 3;
pub const STATUS_UNSUPPORTED: u32 = 4;
pub const STATUS_BUFFER_TOO_SMALL: u32 = 5;
pub const DEF_CAN_UDS_DATA: u32 = 1;
pub const DEF_LIN_UDS_DATA: u32 = 2;
pub const DEF_DOIP_UDS_DATA: u32 = 3;
pub const CMD_DESIP: u32 = 0;
pub const CMD_DESPORT: u32 = 1;
pub const CMD_CHGDESIPANDPORT: u32 = 2;
pub const CMD_SRCPORT: u32 = 2;
pub const CMD_TCP_TYPE: u32 = 4;
pub const TCP_CLIENT: u32 = 0;
pub const TCP_SERVER: u32 = 1;
pub const CMD_CLIENT_COUNT: u32 = 5;
pub const CMD_CLIENT: u32 = 6;
pub const CMD_DISCONN_CLINET: u32 = 7;
pub const CMD_SET_RECONNECT_TIME: u32 = 8;
pub const TYPE_CAN: u32 = 0;
pub const TYPE_CANFD: u32 = 1;
pub const TYPE_ALL_DATA: u32 = 2;
pub const ZCAN_DYNAMIC_CONFIG_DEVNAME: &[u8; 23] = b"DYNAMIC_CONFIG_DEVNAME\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_ENABLE: &[u8; 28] = b"DYNAMIC_CONFIG_CAN%d_ENABLE\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_MODE: &[u8; 26] = b"DYNAMIC_CONFIG_CAN%d_MODE\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_TXATTEMPTS: &[u8; 32] = b"DYNAMIC_CONFIG_CAN%d_TXATTEMPTS\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_NOMINALBAUD: &[u8; 33] = b"DYNAMIC_CONFIG_CAN%d_NOMINALBAUD\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_DATABAUD: &[u8; 30] = b"DYNAMIC_CONFIG_CAN%d_DATABAUD\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_USERES: &[u8; 28] = b"DYNAMIC_CONFIG_CAN%d_USERES\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_SNDCFG_INTERVAL: &[u8; 37] =
    b"DYNAMIC_CONFIG_CAN%d_SNDCFG_INTERVAL\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_BUSRATIO_ENABLE: &[u8; 37] =
    b"DYNAMIC_CONFIG_CAN%d_BUSRATIO_ENABLE\0";
pub const ZCAN_DYNAMIC_CONFIG_CAN_BUSRATIO_PERIOD: &[u8; 37] =
    b"DYNAMIC_CONFIG_CAN%d_BUSRATIO_PERIOD\0";
pub const CANFD_FILTER_COUNT_MAX: u32 = 16;
pub const CANFD_DATA_LEN_MAX: u32 = 64;
pub const DYNAMIC_CONFIG_CAN: u32 = 0;
pub const DYNAMIC_CONFIG_FILTER: u32 = 1;
pub const CANFD_FILTER_BLACK_LIST: u32 = 0;
pub const CANFD_FILTER_WHITE_LIST: u32 = 1;
pub const ZCLOUD_MAX_DEVICES: u32 = 100;
pub const ZCLOUD_MAX_CHANNEL: u32 = 16;
pub const ZCAN_LIN_WAKE_UP: u32 = 1;
pub const ZCAN_LIN_ENTERED_SLEEP_MODE: u32 = 2;
pub const ZCAN_LIN_EXITED_SLEEP_MODE: u32 = 3;
pub const ZCAN_UDS_TRANS_VER_0: u32 = 0;
pub const ZCAN_UDS_TRANS_VER_1: u32 = 1;
pub const ZCAN_UDS_FRAME_CAN: u32 = 0;
pub const ZCAN_UDS_FRAME_CANFD: u32 = 1;
pub const ZCAN_UDS_FRAME_CANFD_BRS: u32 = 2;
pub const ZCAN_DOIP_ACTIVATION_DEFAULT: u32 = 0;
pub const ZCAN_DOIP_ACTIVATION_WWH_OBD: u32 = 1;
pub const ZCAN_DOIP_ACTIVATION_CENTRAL_SECURITY: u32 = 224;
pub const ZCAN_DOIP_ISO_13400_2_2010: u32 = 1;
pub const ZCAN_DOIP_ISO_13400_2_2012: u32 = 2;
pub const ZCAN_DOIP_ISO_13400_2_2019: u32 = 3;
pub const ZCAN_DOIP_AUTO_DETECTED_VERSION: u32 = 255;
pub const ZCAN_UDS_ERROR_OK: u32 = 0;
pub const ZCAN_UDS_ERROR_TIMEOUT: u32 = 1;
pub const ZCAN_UDS_ERROR_TRANSPORT: u32 = 2;
pub const ZCAN_UDS_ERROR_CANCEL: u32 = 3;
pub const ZCAN_UDS_ERROR_SUPPRESS_RESPONSE: u32 = 4;
pub const ZCAN_UDS_ERROR_BUSY: u32 = 5;
pub const ZCAN_UDS_ERROR_REQ_PARAM: u32 = 6;
pub const ZCAN_UDS_ERROR_OTHTER: u32 = 100;
pub const ZCAN_UDS_ERROR_DOIP_FAILED_TO_CREATE_SOCKET: u32 = 32;
pub const ZCAN_UDS_ERROR_DOIP_FAILED_TO_CONNECT: u32 = 33;
pub const ZCAN_UDS_ERROR_DOIP_TIMEOUT: u32 = 34;
pub const ZCAN_UDS_ERROR_DOIP_ROUTING_NOT_ACTIVE: u32 = 35;
pub const ZCAN_UDS_ERROR_DOIP_BUFFER_TOO_SMALL: u32 = 36;
pub const ZCAN_UDS_ERROR_DOIP_ROUTING_ALREADY_ACTIVE: u32 = 37;
pub const ZCAN_UDS_ERROR_DOIP_HEADER_NACK_INCORRECT_PATTERN_FORMAT: u32 = 38;
pub const ZCAN_UDS_ERROR_DOIP_HEADER_NACK_UNKNOWN_PAYLOAD_TYPE: u32 = 39;
pub const ZCAN_UDS_ERROR_DOIP_HEADER_NACK_MESSAGE_TOO_LARGE: u32 = 40;
pub const ZCAN_UDS_ERROR_DOIP_HEADER_NACK_OUT_OF_MEMORY: u32 = 41;
pub const ZCAN_UDS_ERROR_DOIP_HEADER_NACK_INVALID_PAYLOAD_LENGTH: u32 = 42;
pub const ZCAN_UDS_ERROR_DOIP_HEADER_NACK_UNKNOWN: u32 = 43;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_INVALID_SOURCE_ADDRESS: u32 = 44;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_UNKNOWN_TARGET_ADDRESS: u32 = 45;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_MESSAGE_TOO_LARGE: u32 = 46;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_OUT_OF_MEMORY: u32 = 47;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_TARGET_UNREACHABLE: u32 = 48;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_UNKNOWN_NETWORK: u32 = 49;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_TRANSPORT_PROTOCOL_ERROR: u32 = 50;
pub const ZCAN_UDS_ERROR_DOIP_DIAGNOSTIC_NACK_UNKNOWN: u32 = 51;
pub const ZCAN_UDS_ERROR_DOIP_INVALID_HANDLE: u32 = 52;
pub const ZCAN_UDS_ERROR_DOIP_UNEXPECTED_NULL_POINTER: u32 = 53;
pub const ZCAN_UDS_ERROR_DOIP_UNKNOWN_HANDLE: u32 = 54;
pub const ZCAN_UDS_ERROR_DOIP_OUT_OF_MEMORY: u32 = 55;
pub const ZCAN_UDS_ERROR_DOIP_UNKNOWN_ERROR: u32 = 56;
pub const ZCAN_UDS_ERROR_DOIP_ROUTING_ACTIVE_FAIL: u32 = 57;
pub const ZCAN_UDS_RT_NEGATIVE: u32 = 0;
pub const ZCAN_UDS_RT_POSITIVE: u32 = 1;
pub const ZCAN_UDS_RT_NONE: u32 = 2;
pub const ZCAN_UDS_CTRL_STOP_REQ: u32 = 0;
pub const ZCAN_UDS_CTRL_RESULT_OK: u32 = 0;
pub const ZCAN_UDS_CTRL_RESULT_ERR: u32 = 1;
pub const INVALID_DEVICE_HANDLE: u32 = 0;
pub const INVALID_CHANNEL_HANDLE: u32 = 0;
pub type va_list = *mut ::core::ffi::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::core::ffi::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::core::ffi::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::core::ffi::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::core::ffi::c_int;
pub type wint_t = ::core::ffi::c_ushort;
pub type wctype_t = ::core::ffi::c_ushort;
pub type __time32_t = ::core::ffi::c_long;
pub type __time64_t = ::core::ffi::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::core::ffi::c_ushort,
    pub _locale_mb_cur_max: ::core::ffi::c_int,
    pub _locale_lc_codepage: ::core::ffi::c_uint,
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::core::ffi::c_ulong,
    pub _Byte: ::core::ffi::c_ushort,
    pub _State: ::core::ffi::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut wchar_t;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut wchar_t, _SizeInWords: usize, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime32_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime64_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
pub type clock_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
extern "C" {
    pub fn __daylight() -> *mut ::core::ffi::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::core::ffi::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::core::ffi::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::core::ffi::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::core::ffi::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::core::ffi::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut usize,
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Index: ::core::ffi::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Format: *const ::core::ffi::c_char,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::core::ffi::c_char,
        _MaxSize: usize,
        _Format: *const ::core::ffi::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::core::ffi::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::core::ffi::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(_Ts: *mut _timespec32, _Base: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _timespec64_get(_Ts: *mut _timespec64, _Base: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn _setsystime(_Tm: *mut tm, _Milliseconds: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn tzset();
}
pub type BYTE = ::core::ffi::c_uchar;
pub type UINT = ::core::ffi::c_uint;
pub type ULONG = ::core::ffi::c_ulong;
pub type UINT64 = ::core::ffi::c_ulonglong;
pub type USHORT = ::core::ffi::c_ushort;
pub type UCHAR = ::core::ffi::c_uchar;
pub type canid_t = UINT;
pub type can_err_mask_t = UINT;
#[doc = " struct can_frame - basic CAN frame structure\n @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition\n @can_dlc: frame payload length in byte (0 .. 8) aka data length code\n           N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1\n           mapping of the 'data length code' to the real payload length\n @__pad:   padding\n @__res0:  reserved / padding\n @__res1:  reserved / padding\n @data:    CAN frame payload (up to 8 byte)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct can_frame {
    pub can_id: canid_t,
    pub can_dlc: BYTE,
    pub __pad: BYTE,
    pub __res0: BYTE,
    pub __res1: BYTE,
    pub data: [BYTE; 8usize],
}
#[doc = " struct canfd_frame - CAN flexible data rate frame structure\n @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition\n @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)\n @flags:  additional flags for CAN FD\n @__res0: reserved / padding\n @__res1: reserved / padding\n @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct canfd_frame {
    pub can_id: canid_t,
    pub len: BYTE,
    pub flags: BYTE,
    pub __res0: BYTE,
    pub __res1: BYTE,
    pub data: [BYTE; 64usize],
}
impl Default for canfd_frame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Meta\n 节点mata信息。"]
pub type Meta = _Meta;
#[doc = "  \\struct Pair\n  属性的KeyValue对。"]
pub type Pair = _Pair;
#[doc = "  \\struct Options\n 节点mata的可选项。"]
pub type Options = _Options;
#[doc = "  \\struct ConfigNode\n  ConfigNode"]
pub type ConfigNode = _ConfigNode;
#[doc = "  \\struct Options\n 节点mata的可选项。"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Options {
    #[doc = " 可选项的数据类型"]
    pub type_: *const ::core::ffi::c_char,
    #[doc = " 可选项的值"]
    pub value: *const ::core::ffi::c_char,
    #[doc = " 可选项的描述信息"]
    pub desc: *const ::core::ffi::c_char,
}
impl Default for _Options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Meta\n 节点mata信息。"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Meta {
    #[doc = " 配置项的数据类型"]
    pub type_: *const ::core::ffi::c_char,
    #[doc = " 配置项的说明性信息"]
    pub desc: *const ::core::ffi::c_char,
    #[doc = " 配置项是否是只读的，缺省为可读写"]
    pub read_only: ::core::ffi::c_int,
    #[doc = " 配置项输入格式的提示"]
    pub format: *const ::core::ffi::c_char,
    #[doc = " 对于数值类型的配置项来说是最小值，对字符串的配置项来说是最小长度（字节数）。"]
    pub min_value: f64,
    #[doc = " 对于数值类型的配置项来说是最大值，对字符串的配置项来说是最大长度（字节数）。"]
    pub max_value: f64,
    #[doc = " 配置项的单位"]
    pub unit: *const ::core::ffi::c_char,
    #[doc = " 通过旋钮/滚轮等方式修改配置项时的增量"]
    pub delta: f64,
    #[doc = " 配置项是否可见, true可见，false不可见，也可以绑定表达式（表达式使用参考demo3），缺省可见"]
    pub visible: *const ::core::ffi::c_char,
    #[doc = " 该配置项是否使能, true使能，false不使能，也可以绑定表达式（表达式使用参考demo3）。缺省使能"]
    pub enable: *const ::core::ffi::c_char,
    #[doc = " 配置项的可选值，仅但『type』为间接类型时有效"]
    pub editable: ::core::ffi::c_int,
    #[doc = " 配置项的可选值，仅但『type』为间接类型时有效，以NULL结束"]
    pub options: *mut *mut Options,
}
impl Default for _Meta {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Pair\n  属性的KeyValue对。"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pair {
    pub key: *const ::core::ffi::c_char,
    pub value: *const ::core::ffi::c_char,
}
impl Default for _Pair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct ConfigNode\n  ConfigNode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ConfigNode {
    #[doc = " 节点的名字"]
    pub name: *const ::core::ffi::c_char,
    #[doc = " 节点的值 同样可以绑定表达式"]
    pub value: *const ::core::ffi::c_char,
    #[doc = " 节点值的表达式，当有该表达式时，value由此表达式计算而来"]
    pub binding_value: *const ::core::ffi::c_char,
    #[doc = " 该节点的路径"]
    pub path: *const ::core::ffi::c_char,
    #[doc = " 配置项信息"]
    pub meta_info: *mut Meta,
    #[doc = " 该节点的子节点, 以NULL结束"]
    pub children: *mut *mut ConfigNode,
    #[doc = " 该节点的属性, 以NULL结束"]
    pub attributes: *mut *mut Pair,
}
impl Default for _ConfigNode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief 获取属性的描述信息。\n\n \\retval ConfigNode"]
pub type GetPropertysFunc = ::core::option::Option<unsafe extern "C" fn() -> *const ConfigNode>;
#[doc = " \\brief 设置指定路径的属性的值。\n \\param[in] path  : 属性的路径。\n \\param[in] value : 属性的值。\n\n \\retval 成功返回1，失败返回0。"]
pub type SetValueFunc = ::core::option::Option<
    unsafe extern "C" fn(
        path: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief 获取指定路径的属性的值。\n \\param[in] path  : 属性的路径。\n \\retval 成功返回属性的值，失败返回NULL。"]
pub type GetValueFunc = ::core::option::Option<
    unsafe extern "C" fn(path: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagIProperty {
    pub SetValue: SetValueFunc,
    pub GetValue: GetValueFunc,
    pub GetPropertys: GetPropertysFunc,
}
pub type IProperty = tagIProperty;
pub type ZCAN_RET_STATUS = UINT;
pub type ZCAN_LAST_ERROR_STATUS = UINT;
pub type ZCAN_UDS_DATA_DEF = UINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_DYNAMIC_CONFIG_DATA {
    pub key: [::core::ffi::c_char; 64usize],
    pub value: [::core::ffi::c_char; 64usize],
}
impl Default for tagZCAN_DYNAMIC_CONFIG_DATA {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_DYNAMIC_CONFIG_DATA = tagZCAN_DYNAMIC_CONFIG_DATA;
pub type DynamicConfigDataType = UINT;
#[repr(C)]
#[derive(Copy, Clone)]
pub union unionCANFDFilterRulePresent {
    pub unionValue: unionCANFDFilterRulePresent__bindgen_ty_1,
    pub rawValue: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct unionCANFDFilterRulePresent__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl unionCANFDFilterRulePresent__bindgen_ty_1 {
    #[inline]
    pub fn bChnl(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bChnl(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFD(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bFD(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bEXT(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bEXT(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bRTR(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bRTR(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bLen(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bLen(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bID(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bID(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bTime(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bTime(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bFilterMask(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bFilterMask(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bErr(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bErr(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nReserved(&self) -> ::core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_nReserved(&mut self, val: ::core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bChnl: ::core::ffi::c_uint,
        bFD: ::core::ffi::c_uint,
        bEXT: ::core::ffi::c_uint,
        bRTR: ::core::ffi::c_uint,
        bLen: ::core::ffi::c_uint,
        bID: ::core::ffi::c_uint,
        bTime: ::core::ffi::c_uint,
        bFilterMask: ::core::ffi::c_uint,
        bErr: ::core::ffi::c_uint,
        nReserved: ::core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bChnl: u32 = unsafe { ::core::mem::transmute(bChnl) };
            bChnl as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let bFD: u32 = unsafe { ::core::mem::transmute(bFD) };
            bFD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bEXT: u32 = unsafe { ::core::mem::transmute(bEXT) };
            bEXT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let bRTR: u32 = unsafe { ::core::mem::transmute(bRTR) };
            bRTR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let bLen: u32 = unsafe { ::core::mem::transmute(bLen) };
            bLen as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let bID: u32 = unsafe { ::core::mem::transmute(bID) };
            bID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let bTime: u32 = unsafe { ::core::mem::transmute(bTime) };
            bTime as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let bFilterMask: u32 = unsafe { ::core::mem::transmute(bFilterMask) };
            bFilterMask as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bErr: u32 = unsafe { ::core::mem::transmute(bErr) };
            bErr as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let nReserved: u32 = unsafe { ::core::mem::transmute(nReserved) };
            nReserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for unionCANFDFilterRulePresent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CANFD_FILTER_RULE {
    pub presentFlag: unionCANFDFilterRulePresent,
    pub nErr: ::core::ffi::c_int,
    pub nChnl: ::core::ffi::c_int,
    pub nFD: ::core::ffi::c_int,
    pub nExt: ::core::ffi::c_int,
    pub nRtr: ::core::ffi::c_int,
    pub nLen: ::core::ffi::c_int,
    pub nBeginID: ::core::ffi::c_int,
    pub nEndID: ::core::ffi::c_int,
    pub nBeginTime: ::core::ffi::c_int,
    pub nEndTime: ::core::ffi::c_int,
    pub nFilterDataLen: ::core::ffi::c_int,
    pub nMaskDataLen: ::core::ffi::c_int,
    pub nFilterData: [BYTE; 64usize],
    pub nMaskData: [BYTE; 64usize],
}
impl Default for CANFD_FILTER_RULE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type enumCANFDFilterBlackWhiteList = UINT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CANFD_FILTER_CFG {
    pub bEnable: ::core::ffi::c_int,
    pub enBlackWhiteList: enumCANFDFilterBlackWhiteList,
    pub vecFilters: [CANFD_FILTER_RULE; 16usize],
}
impl Default for CANFD_FILTER_CFG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCAN_DYNAMIC_CONFIG {
    pub dynamicConfigDataType: DynamicConfigDataType,
    pub isPersist: UINT,
    pub data: tagZCAN_DYNAMIC_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCAN_DYNAMIC_CONFIG__bindgen_ty_1 {
    pub filterCfg: CANFD_FILTER_CFG,
    pub reserved: [BYTE; 10240usize],
}
impl Default for tagZCAN_DYNAMIC_CONFIG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCAN_DYNAMIC_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_DYNAMIC_CONFIG = tagZCAN_DYNAMIC_CONFIG;
pub type DEVICE_HANDLE = *mut ::core::ffi::c_void;
pub type CHANNEL_HANDLE = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_DEVICE_INFO {
    pub hw_Version: USHORT,
    pub fw_Version: USHORT,
    pub dr_Version: USHORT,
    pub in_Version: USHORT,
    pub irq_Num: USHORT,
    pub can_Num: BYTE,
    pub str_Serial_Num: [UCHAR; 20usize],
    pub str_hw_Type: [UCHAR; 40usize],
    pub reserved: [USHORT; 4usize],
}
impl Default for tagZCAN_DEVICE_INFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_DEVICE_INFO = tagZCAN_DEVICE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG {
    pub can_type: UINT,
    pub config: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1 {
    pub can: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_1,
    pub canfd: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_1 {
    pub acc_code: UINT,
    pub acc_mask: UINT,
    pub reserved: UINT,
    pub filter: BYTE,
    pub timing0: BYTE,
    pub timing1: BYTE,
    pub mode: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_2 {
    pub acc_code: UINT,
    pub acc_mask: UINT,
    pub abit_timing: UINT,
    pub dbit_timing: UINT,
    pub brp: UINT,
    pub filter: BYTE,
    pub mode: BYTE,
    pub pad: USHORT,
    pub reserved: UINT,
}
impl Default for tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCAN_CHANNEL_INIT_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_CHANNEL_INIT_CONFIG = tagZCAN_CHANNEL_INIT_CONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_ERR_INFO {
    pub error_code: UINT,
    pub passive_ErrData: [BYTE; 3usize],
    pub arLost_ErrData: BYTE,
}
pub type ZCAN_CHANNEL_ERR_INFO = tagZCAN_CHANNEL_ERR_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_STATUS {
    pub errInterrupt: BYTE,
    pub regMode: BYTE,
    pub regStatus: BYTE,
    pub regALCapture: BYTE,
    pub regECCapture: BYTE,
    pub regEWLimit: BYTE,
    pub regRECounter: BYTE,
    pub regTECounter: BYTE,
    pub Reserved: UINT,
}
pub type ZCAN_CHANNEL_STATUS = tagZCAN_CHANNEL_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_Transmit_Data {
    pub frame: can_frame,
    pub transmit_type: UINT,
}
pub type ZCAN_Transmit_Data = tagZCAN_Transmit_Data;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_Receive_Data {
    pub frame: can_frame,
    pub timestamp: UINT64,
}
pub type ZCAN_Receive_Data = tagZCAN_Receive_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_TransmitFD_Data {
    pub frame: canfd_frame,
    pub transmit_type: UINT,
}
impl Default for tagZCAN_TransmitFD_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_TransmitFD_Data = tagZCAN_TransmitFD_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_ReceiveFD_Data {
    pub frame: canfd_frame,
    pub timestamp: UINT64,
}
impl Default for tagZCAN_ReceiveFD_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_ReceiveFD_Data = tagZCAN_ReceiveFD_Data;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_AUTO_TRANSMIT_OBJ {
    pub enable: USHORT,
    pub index: USHORT,
    pub interval: UINT,
    pub obj: ZCAN_Transmit_Data,
}
pub type ZCAN_AUTO_TRANSMIT_OBJ = tagZCAN_AUTO_TRANSMIT_OBJ;
pub type PZCAN_AUTO_TRANSMIT_OBJ = *mut tagZCAN_AUTO_TRANSMIT_OBJ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCANFD_AUTO_TRANSMIT_OBJ {
    pub enable: USHORT,
    pub index: USHORT,
    pub interval: UINT,
    pub obj: ZCAN_TransmitFD_Data,
}
impl Default for tagZCANFD_AUTO_TRANSMIT_OBJ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANFD_AUTO_TRANSMIT_OBJ = tagZCANFD_AUTO_TRANSMIT_OBJ;
pub type PZCANFD_AUTO_TRANSMIT_OBJ = *mut tagZCANFD_AUTO_TRANSMIT_OBJ;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_AUTO_TRANSMIT_OBJ_PARAM {
    pub index: USHORT,
    pub type_: USHORT,
    pub value: UINT,
}
pub type ZCAN_AUTO_TRANSMIT_OBJ_PARAM = tagZCAN_AUTO_TRANSMIT_OBJ_PARAM;
pub type PZCAN_AUTO_TRANSMIT_OBJ_PARAM = *mut tagZCAN_AUTO_TRANSMIT_OBJ_PARAM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCLOUD_CHNINFO {
    pub enable: BYTE,
    pub type_: BYTE,
    pub isUpload: BYTE,
    pub isDownload: BYTE,
}
pub type ZCLOUD_CHNINFO = tagZCLOUD_CHNINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCLOUD_DEVINFO {
    pub devIndex: ::core::ffi::c_int,
    pub type_: [::core::ffi::c_char; 64usize],
    pub id: [::core::ffi::c_char; 64usize],
    pub name: [::core::ffi::c_char; 64usize],
    pub owner: [::core::ffi::c_char; 64usize],
    pub model: [::core::ffi::c_char; 64usize],
    pub fwVer: [::core::ffi::c_char; 16usize],
    pub hwVer: [::core::ffi::c_char; 16usize],
    pub serial: [::core::ffi::c_char; 64usize],
    pub status: ::core::ffi::c_int,
    pub bGpsUpload: BYTE,
    pub channelCnt: BYTE,
    pub channels: [ZCLOUD_CHNINFO; 16usize],
}
impl Default for tagZCLOUD_DEVINFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCLOUD_DEVINFO = tagZCLOUD_DEVINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCLOUD_USER_DATA {
    pub username: [::core::ffi::c_char; 64usize],
    pub mobile: [::core::ffi::c_char; 64usize],
    pub dllVer: [::core::ffi::c_char; 16usize],
    pub devCnt: usize,
    pub devices: [ZCLOUD_DEVINFO; 100usize],
}
impl Default for tagZCLOUD_USER_DATA {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCLOUD_USER_DATA = tagZCLOUD_USER_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCLOUD_GPS_FRAME {
    pub latitude: f32,
    pub longitude: f32,
    pub speed: f32,
    pub tm: tagZCLOUD_GPS_FRAME___gps_time,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCLOUD_GPS_FRAME___gps_time {
    pub year: USHORT,
    pub mon: USHORT,
    pub day: USHORT,
    pub hour: USHORT,
    pub min: USHORT,
    pub sec: USHORT,
}
pub type ZCLOUD_GPS_FRAME = tagZCLOUD_GPS_FRAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagUSBCANFDTxTimeStamp {
    pub pTxTimeStampBuffer: *mut UINT,
    pub nBufferTimeStampCount: UINT,
}
impl Default for tagUSBCANFDTxTimeStamp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type USBCANFDTxTimeStamp = tagUSBCANFDTxTimeStamp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTxTimeStamp {
    pub pTxTimeStampBuffer: *mut UINT64,
    pub nBufferTimeStampCount: UINT,
    pub nWaitTime: ::core::ffi::c_int,
}
impl Default for tagTxTimeStamp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TxTimeStamp = tagTxTimeStamp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagBusUsage {
    pub nTimeStampBegin: UINT64,
    pub nTimeStampEnd: UINT64,
    pub nChnl: BYTE,
    pub nReserved: BYTE,
    pub nBusUsage: USHORT,
    pub nFrameCount: UINT,
}
pub type BusUsage = tagBusUsage;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_NO_ERR: eZCANErrorDEF = 0;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_BUS_ERR: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_CONTROLLER_ERR: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_DEVICE_ERR: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_ACTIVE: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_WARNNING: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_PASSIVE: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_BUSOFF: eZCANErrorDEF = 4;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_NO_ERR: eZCANErrorDEF = 0;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_BIT_ERR: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_ACK_ERR: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_CRC_ERR: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_FORM_ERR: eZCANErrorDEF = 4;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_STUFF_ERR: eZCANErrorDEF = 5;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_OVERLOAD_ERR: eZCANErrorDEF = 6;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_ARBITRATION_LOST: eZCANErrorDEF = 7;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_NODE_STATE_CHAGE: eZCANErrorDEF = 8;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_RX_FIFO_OVERFLOW: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_DRIVER_RX_BUFFER_OVERFLOW: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_DRIVER_TX_BUFFER_OVERFLOW: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_INTERNAL_ERROR: eZCANErrorDEF = 4;
pub const eZCANErrorDEF_ZCAN_DEVICE_APP_RX_BUFFER_OVERFLOW: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_DEVICE_APP_TX_BUFFER_OVERFLOW: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_DEVICE_APP_AUTO_SEND_FAILED: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_TX_FRAME_INVALID: eZCANErrorDEF = 4;
pub type eZCANErrorDEF = ::core::ffi::c_int;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_CAN_CANFD_DATA: eZCANDataDEF = 1;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_ERROR_DATA: eZCANDataDEF = 2;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_GPS_DATA: eZCANDataDEF = 3;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_DATA: eZCANDataDEF = 4;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_BUSUSAGE_DATA: eZCANDataDEF = 5;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_ERROR_DATA: eZCANDataDEF = 6;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_EX_DATA: eZCANDataDEF = 7;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_EVENT_DATA: eZCANDataDEF = 8;
pub const eZCANDataDEF_ZCAN_TX_DELAY_NO_DELAY: eZCANDataDEF = 0;
pub const eZCANDataDEF_ZCAN_TX_DELAY_UNIT_MS: eZCANDataDEF = 1;
pub const eZCANDataDEF_ZCAN_TX_DELAY_UNIT_100US: eZCANDataDEF = 2;
pub type eZCANDataDEF = ::core::ffi::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANCANFDData {
    pub timeStamp: UINT64,
    pub flag: tagZCANCANFDData__bindgen_ty_1,
    pub extraData: [BYTE; 4usize],
    pub frame: canfd_frame,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANCANFDData__bindgen_ty_1 {
    pub unionVal: tagZCANCANFDData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: UINT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANCANFDData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl tagZCANCANFDData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frameType(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frameType(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn txDelay(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_txDelay(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn transmitType(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_transmitType(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn txEchoRequest(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txEchoRequest(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txEchoed(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txEchoed(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frameType: UINT,
        txDelay: UINT,
        transmitType: UINT,
        txEchoRequest: UINT,
        txEchoed: UINT,
        reserved: UINT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let frameType: u32 = unsafe { ::core::mem::transmute(frameType) };
            frameType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let txDelay: u32 = unsafe { ::core::mem::transmute(txDelay) };
            txDelay as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let transmitType: u32 = unsafe { ::core::mem::transmute(transmitType) };
            transmitType as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let txEchoRequest: u32 = unsafe { ::core::mem::transmute(txEchoRequest) };
            txEchoRequest as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let txEchoed: u32 = unsafe { ::core::mem::transmute(txEchoed) };
            txEchoed as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANCANFDData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANCANFDData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANCANFDData = tagZCANCANFDData;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANErrorData {
    pub timeStamp: UINT64,
    pub errType: BYTE,
    pub errSubType: BYTE,
    pub nodeState: BYTE,
    pub rxErrCount: BYTE,
    pub txErrCount: BYTE,
    pub errData: BYTE,
    pub reserved: [BYTE; 2usize],
}
pub type ZCANErrorData = tagZCANErrorData;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANGPSData {
    pub time: tagZCANGPSData__bindgen_ty_1,
    pub flag: tagZCANGPSData__bindgen_ty_2,
    pub latitude: f64,
    pub longitude: f64,
    pub altitude: f64,
    pub speed: f64,
    pub courseAngle: f64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANGPSData__bindgen_ty_1 {
    pub year: USHORT,
    pub mon: USHORT,
    pub day: USHORT,
    pub hour: USHORT,
    pub min: USHORT,
    pub sec: USHORT,
    pub milsec: USHORT,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANGPSData__bindgen_ty_2 {
    pub unionVal: tagZCANGPSData__bindgen_ty_2__bindgen_ty_1,
    pub rawVal: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANGPSData__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl tagZCANGPSData__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn timeValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_timeValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn latlongValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_latlongValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn altitudeValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_altitudeValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn speedValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_speedValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn courseAngleValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_courseAngleValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        timeValid: USHORT,
        latlongValid: USHORT,
        altitudeValid: USHORT,
        speedValid: USHORT,
        courseAngleValid: USHORT,
        reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let timeValid: u16 = unsafe { ::core::mem::transmute(timeValid) };
            timeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let latlongValid: u16 = unsafe { ::core::mem::transmute(latlongValid) };
            latlongValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let altitudeValid: u16 = unsafe { ::core::mem::transmute(altitudeValid) };
            altitudeValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let speedValid: u16 = unsafe { ::core::mem::transmute(speedValid) };
            speedValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let courseAngleValid: u16 = unsafe { ::core::mem::transmute(courseAngleValid) };
            courseAngleValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 13u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANGPSData__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANGPSData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANGPSData = tagZCANGPSData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCANLINData {
    pub PID: tagZCANLINData__bindgen_ty_1,
    pub RxData: tagZCANLINData__bindgen_ty_2,
    pub reserved: [BYTE; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANLINData__bindgen_ty_1 {
    pub unionVal: tagZCANLINData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tagZCANLINData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Parity(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Parity(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: BYTE, Parity: BYTE) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Parity: u8 = unsafe { ::core::mem::transmute(Parity) };
            Parity as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINData__bindgen_ty_2 {
    pub timeStamp: UINT64,
    pub dataLen: BYTE,
    pub dir: BYTE,
    pub chkSum: BYTE,
    pub reserved: [BYTE; 13usize],
    pub data: [BYTE; 8usize],
}
impl Default for tagZCANLINData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINData = tagZCANLINData;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANLINErrData {
    pub timeStamp: UINT64,
    pub PID: tagZCANLINErrData__bindgen_ty_1,
    pub dataLen: BYTE,
    pub data: [BYTE; 8usize],
    pub errData: tagZCANLINErrData__bindgen_ty_2,
    pub dir: BYTE,
    pub chkSum: BYTE,
    pub reserved: [BYTE; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANLINErrData__bindgen_ty_1 {
    pub unionVal: tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Parity(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Parity(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: BYTE, Parity: BYTE) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Parity: u8 = unsafe { ::core::mem::transmute(Parity) };
            Parity as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINErrData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANLINErrData__bindgen_ty_2 {
    pub flag: tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1,
    pub unionErrData: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn errStage(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_errStage(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn errReason(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_errReason(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        errStage: USHORT,
        errReason: USHORT,
        reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let errStage: u16 = unsafe { ::core::mem::transmute(errStage) };
            errStage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let errReason: u16 = unsafe { ::core::mem::transmute(errReason) };
            errReason as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINErrData__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANLINErrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINErrData = tagZCANLINErrData;
pub type ZCAN_LIN_EVENT_TYPE = BYTE;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINEventData {
    pub timeStamp: UINT64,
    pub type_: ZCAN_LIN_EVENT_TYPE,
    pub reserved: [BYTE; 7usize],
}
pub type ZCANLINEventData = tagZCANLINEventData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCANLINExData {
    pub PID: tagZCANLINExData__bindgen_ty_1,
    pub reserved: [BYTE; 7usize],
    pub RxData: tagZCANLINExData__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANLINExData__bindgen_ty_1 {
    pub unionVal: tagZCANLINExData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINExData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tagZCANLINExData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Parity(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Parity(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: BYTE, Parity: BYTE) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Parity: u8 = unsafe { ::core::mem::transmute(Parity) };
            Parity as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINExData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCANLINExData__bindgen_ty_2 {
    pub timeStamp: UINT64,
    pub dataLen: BYTE,
    pub dir: BYTE,
    pub chkSum: BYTE,
    pub reserved: [BYTE; 5usize],
    pub data: [BYTE; 64usize],
}
impl Default for tagZCANLINExData__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANLINExData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINExData = tagZCANLINExData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCANDataObj {
    pub dataType: BYTE,
    pub chnl: BYTE,
    pub flag: tagZCANDataObj__bindgen_ty_1,
    pub extraData: [BYTE; 4usize],
    pub data: tagZCANDataObj__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANDataObj__bindgen_ty_1 {
    pub unionVal: tagZCANDataObj__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANDataObj__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tagZCANDataObj__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANDataObj__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANDataObj__bindgen_ty_2 {
    pub zcanCANFDData: ZCANCANFDData,
    pub zcanErrData: ZCANErrorData,
    pub zcanGPSData: ZCANGPSData,
    pub zcanLINData: ZCANLINData,
    pub zcanLINErrData: ZCANLINErrData,
    pub zcanLINExData: ZCANLINExData,
    pub zcanLINEventData: ZCANLINEventData,
    pub busUsage: BusUsage,
    pub raw: [BYTE; 92usize],
}
impl Default for tagZCANDataObj__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANDataObj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANDataObj = tagZCANDataObj;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VCI_LIN_MSG {
    pub chnl: BYTE,
    pub dataType: BYTE,
    pub data: _VCI_LIN_MSG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VCI_LIN_MSG__bindgen_ty_1 {
    pub zcanLINData: ZCANLINData,
    pub zcanLINErrData: ZCANLINErrData,
    pub zcanLINEventData: ZCANLINEventData,
    pub raw: [BYTE; 46usize],
}
impl Default for _VCI_LIN_MSG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VCI_LIN_MSG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_LIN_MSG = _VCI_LIN_MSG;
pub type PZCAN_LIN_MSG = *mut _VCI_LIN_MSG;
pub const eZLINChkSumMode_DEFAULT: eZLINChkSumMode = 0;
pub const eZLINChkSumMode_CLASSIC_CHKSUM: eZLINChkSumMode = 1;
pub const eZLINChkSumMode_ENHANCE_CHKSUM: eZLINChkSumMode = 2;
pub const eZLINChkSumMode_AUTOMATIC: eZLINChkSumMode = 3;
pub type eZLINChkSumMode = ::core::ffi::c_int;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_INIT_CONFIG {
    pub linMode: BYTE,
    pub chkSumMode: BYTE,
    pub maxLength: BYTE,
    pub reserved: BYTE,
    pub linBaud: UINT,
}
pub type ZCAN_LIN_INIT_CONFIG = _VCI_LIN_INIT_CONFIG;
pub type PZCAN_LIN_INIT_CONFIG = *mut _VCI_LIN_INIT_CONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_PUBLISH_CFG {
    pub ID: BYTE,
    pub dataLen: BYTE,
    pub data: [BYTE; 8usize],
    pub chkSumMode: BYTE,
    pub reserved: [BYTE; 5usize],
}
pub type ZCAN_LIN_PUBLISH_CFG = _VCI_LIN_PUBLISH_CFG;
pub type PZCAN_LIN_PUBLISH_CFG = *mut _VCI_LIN_PUBLISH_CFG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _VCI_LIN_PUBLISH_CFG_EX {
    pub ID: BYTE,
    pub dataLen: BYTE,
    pub data: [BYTE; 64usize],
    pub chkSumMode: BYTE,
    pub reserved: [BYTE; 5usize],
}
impl Default for _VCI_LIN_PUBLISH_CFG_EX {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_LIN_PUBLISH_CFG_EX = _VCI_LIN_PUBLISH_CFG_EX;
pub type PZCAN_LIN_PUBLISH_CFG_EX = *mut _VCI_LIN_PUBLISH_CFG_EX;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_SUBSCIBE_CFG {
    pub ID: BYTE,
    pub dataLen: BYTE,
    pub chkSumMode: BYTE,
    pub reserved: [BYTE; 5usize],
}
pub type ZCAN_LIN_SUBSCIBE_CFG = _VCI_LIN_SUBSCIBE_CFG;
pub type PZCAN_LIN_SUBSCIBE_CFG = *mut _VCI_LIN_SUBSCIBE_CFG;
pub type ZCAN_UDS_TRANS_VER = BYTE;
pub type ZCAN_UDS_FRAME_TYPE = BYTE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST {
    pub req_id: UINT,
    pub channel: BYTE,
    pub frame_type: ZCAN_UDS_FRAME_TYPE,
    pub reserved0: [BYTE; 2usize],
    pub src_addr: UINT,
    pub dst_addr: UINT,
    pub suppress_response: BYTE,
    pub sid: BYTE,
    pub reserved1: [BYTE; 6usize],
    pub session_param: _ZCAN_UDS_REQUEST__bindgen_ty_1,
    pub trans_param: _ZCAN_UDS_REQUEST__bindgen_ty_2,
    pub data: *mut BYTE,
    pub data_len: UINT,
    pub reserved2: UINT,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST__bindgen_ty_1 {
    pub timeout: UINT,
    pub enhanced_timeout: UINT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved0: [BYTE; 7usize],
}
impl _ZCAN_UDS_REQUEST__bindgen_ty_1 {
    #[inline]
    pub fn check_any_negative_response(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_check_any_negative_response(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_if_suppress_response(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_if_suppress_response(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        check_any_negative_response: BYTE,
        wait_if_suppress_response: BYTE,
        flag: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let check_any_negative_response: u8 =
                unsafe { ::core::mem::transmute(check_any_negative_response) };
            check_any_negative_response as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wait_if_suppress_response: u8 =
                unsafe { ::core::mem::transmute(wait_if_suppress_response) };
            wait_if_suppress_response as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag: u8 = unsafe { ::core::mem::transmute(flag) };
            flag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST__bindgen_ty_2 {
    pub version: ZCAN_UDS_TRANS_VER,
    pub max_data_len: BYTE,
    pub local_st_min: BYTE,
    pub block_size: BYTE,
    pub fill_byte: BYTE,
    pub ext_frame: BYTE,
    pub is_modify_ecu_st_min: BYTE,
    pub remote_st_min: BYTE,
    pub fc_timeout: UINT,
    pub reserved0: [BYTE; 4usize],
}
impl Default for _ZCAN_UDS_REQUEST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_UDS_REQUEST = _ZCAN_UDS_REQUEST;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ZLIN_UDS_REQUEST {
    pub req_id: UINT,
    pub channel: BYTE,
    pub suppress_response: BYTE,
    pub sid: BYTE,
    pub Nad: BYTE,
    pub reserved1: [BYTE; 8usize],
    pub session_param: _ZLIN_UDS_REQUEST__bindgen_ty_1,
    pub trans_param: _ZLIN_UDS_REQUEST__bindgen_ty_2,
    pub data: *mut BYTE,
    pub data_len: UINT,
    pub reserved2: UINT,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZLIN_UDS_REQUEST__bindgen_ty_1 {
    pub p2_timeout: UINT,
    pub enhanced_timeout: UINT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved0: [BYTE; 7usize],
}
impl _ZLIN_UDS_REQUEST__bindgen_ty_1 {
    #[inline]
    pub fn check_any_negative_response(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_check_any_negative_response(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_if_suppress_response(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_if_suppress_response(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        check_any_negative_response: BYTE,
        wait_if_suppress_response: BYTE,
        flag: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let check_any_negative_response: u8 =
                unsafe { ::core::mem::transmute(check_any_negative_response) };
            check_any_negative_response as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wait_if_suppress_response: u8 =
                unsafe { ::core::mem::transmute(wait_if_suppress_response) };
            wait_if_suppress_response as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag: u8 = unsafe { ::core::mem::transmute(flag) };
            flag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZLIN_UDS_REQUEST__bindgen_ty_2 {
    pub fill_byte: BYTE,
    pub st_min: BYTE,
    pub reserved0: [BYTE; 6usize],
}
impl Default for _ZLIN_UDS_REQUEST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZLIN_UDS_REQUEST = _ZLIN_UDS_REQUEST;
pub type ZCAN_DOIP_ROUTING_ACT_TYPE = BYTE;
pub type ZCAN_DOIP_VERSION = BYTE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ZDOIP_REQUEST {
    pub req_id: UINT,
    pub reserved0: [BYTE; 4usize],
    pub doipVersion: ZCAN_DOIP_VERSION,
    pub rcType: ZCAN_DOIP_ROUTING_ACT_TYPE,
    pub sourceAddress: [BYTE; 2usize],
    pub serverAddress: [::core::ffi::c_char; 32usize],
    pub connectTimeoutMs: USHORT,
    pub routingTimeoutMs: USHORT,
    pub targetAddress: [BYTE; 2usize],
    pub sid: BYTE,
    pub suppressPosResp: BYTE,
    pub waitForNegResp: BYTE,
    pub reserved1: [BYTE; 3usize],
    pub requestTimeoutMs: UINT,
    pub dataLength: UINT,
    pub data: *mut BYTE,
}
impl Default for _ZDOIP_REQUEST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZDOIP_REQUEST = _ZDOIP_REQUEST;
pub type ZCAN_UDS_ERROR = BYTE;
pub type ZCAN_UDS_RESPONSE_TYPE = BYTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE {
    pub status: ZCAN_UDS_ERROR,
    pub reserved: [BYTE; 6usize],
    pub type_: ZCAN_UDS_RESPONSE_TYPE,
    pub response: _ZCAN_UDS_RESPONSE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ZCAN_UDS_RESPONSE__bindgen_ty_1 {
    pub positive: _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_1,
    pub negative: _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_2,
    pub raw: [BYTE; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_1 {
    pub sid: BYTE,
    pub data_len: UINT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_2 {
    pub neg_code: BYTE,
    pub sid: BYTE,
    pub error_code: BYTE,
}
impl Default for _ZCAN_UDS_RESPONSE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ZCAN_UDS_RESPONSE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_UDS_RESPONSE = _ZCAN_UDS_RESPONSE;
pub type ZCAN_UDS_CTRL_CODE = UINT;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_CTRL_REQ {
    pub reqID: UINT,
    pub cmd: ZCAN_UDS_CTRL_CODE,
    pub reserved: [BYTE; 8usize],
}
pub type ZCAN_UDS_CTRL_REQ = _ZCAN_UDS_CTRL_REQ;
pub type ZCAN_UDS_CTRL_RESULT = UINT;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_CTRL_RESP {
    pub result: ZCAN_UDS_CTRL_RESULT,
    pub reserved: [BYTE; 12usize],
}
pub type ZCAN_UDS_CTRL_RESP = _ZCAN_UDS_CTRL_RESP;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCANCANFDUdsData {
    pub req: *const ZCAN_UDS_REQUEST,
    pub reserved: [BYTE; 24usize],
}
impl Default for tagZCANCANFDUdsData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANCANFDUdsData = tagZCANCANFDUdsData;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCANLINUdsData {
    pub req: *const ZLIN_UDS_REQUEST,
    pub reserved: [BYTE; 24usize],
}
impl Default for tagZCANLINUdsData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINUdsData = tagZCANLINUdsData;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tagZDoIPUdsData {
    pub req: *const ZDOIP_REQUEST,
    pub reserved: [BYTE; 24usize],
}
impl Default for tagZDoIPUdsData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZDoIPUdsData = tagZDoIPUdsData;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANUdsRequestDataObj {
    pub dataType: ZCAN_UDS_DATA_DEF,
    pub data: tagZCANUdsRequestDataObj__bindgen_ty_1,
    pub reserved: [BYTE; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANUdsRequestDataObj__bindgen_ty_1 {
    pub zcanCANFDUdsData: ZCANCANFDUdsData,
    pub zcanLINUdsData: ZCANLINUdsData,
    pub zcanDoIPUdsData: ZDoIPUdsData,
    pub raw: [BYTE; 63usize],
}
impl Default for tagZCANUdsRequestDataObj__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANUdsRequestDataObj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANUdsRequestDataObj = tagZCANUdsRequestDataObj;
extern "C" {
    pub fn ZCAN_OpenDevice(device_type: UINT, device_index: UINT, reserved: UINT) -> DEVICE_HANDLE;
}
extern "C" {
    pub fn ZCAN_CloseDevice(device_handle: DEVICE_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetDeviceInf(device_handle: DEVICE_HANDLE, pInfo: *mut ZCAN_DEVICE_INFO) -> UINT;
}
extern "C" {
    pub fn ZCAN_IsDeviceOnLine(device_handle: DEVICE_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_InitCAN(
        device_handle: DEVICE_HANDLE,
        can_index: UINT,
        pInitConfig: *mut ZCAN_CHANNEL_INIT_CONFIG,
    ) -> CHANNEL_HANDLE;
}
extern "C" {
    pub fn ZCAN_StartCAN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ResetCAN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ClearBuffer(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReadChannelErrInfo(
        channel_handle: CHANNEL_HANDLE,
        pErrInfo: *mut ZCAN_CHANNEL_ERR_INFO,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReadChannelStatus(
        channel_handle: CHANNEL_HANDLE,
        pCANStatus: *mut ZCAN_CHANNEL_STATUS,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetReceiveNum(channel_handle: CHANNEL_HANDLE, type_: BYTE) -> UINT;
}
extern "C" {
    pub fn ZCAN_Transmit(
        channel_handle: CHANNEL_HANDLE,
        pTransmit: *mut ZCAN_Transmit_Data,
        len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_Receive(
        channel_handle: CHANNEL_HANDLE,
        pReceive: *mut ZCAN_Receive_Data,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_TransmitFD(
        channel_handle: CHANNEL_HANDLE,
        pTransmit: *mut ZCAN_TransmitFD_Data,
        len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReceiveFD(
        channel_handle: CHANNEL_HANDLE,
        pReceive: *mut ZCAN_ReceiveFD_Data,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_TransmitData(
        device_handle: DEVICE_HANDLE,
        pTransmit: *mut ZCANDataObj,
        len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReceiveData(
        device_handle: DEVICE_HANDLE,
        pReceive: *mut ZCANDataObj,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetValue(
        device_handle: DEVICE_HANDLE,
        path: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_void,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetValue(
        device_handle: DEVICE_HANDLE,
        path: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_void;
}
extern "C" {
    pub fn GetIProperty(device_handle: DEVICE_HANDLE) -> *mut IProperty;
}
extern "C" {
    pub fn ReleaseIProperty(pIProperty: *mut IProperty) -> UINT;
}
extern "C" {
    pub fn ZCLOUD_SetServerInfo(
        httpSvr: *const ::core::ffi::c_char,
        httpPort: ::core::ffi::c_ushort,
        authSvr: *const ::core::ffi::c_char,
        authPort: ::core::ffi::c_ushort,
    );
}
extern "C" {
    pub fn ZCLOUD_ConnectServer(
        username: *const ::core::ffi::c_char,
        password: *const ::core::ffi::c_char,
    ) -> UINT;
}
extern "C" {
    pub fn ZCLOUD_IsConnected() -> UINT;
}
extern "C" {
    pub fn ZCLOUD_DisconnectServer() -> UINT;
}
extern "C" {
    pub fn ZCLOUD_GetUserData(update: ::core::ffi::c_int) -> *const ZCLOUD_USER_DATA;
}
extern "C" {
    pub fn ZCLOUD_ReceiveGPS(
        device_handle: DEVICE_HANDLE,
        pReceive: *mut ZCLOUD_GPS_FRAME,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_InitLIN(
        device_handle: DEVICE_HANDLE,
        lin_index: UINT,
        pLINInitConfig: PZCAN_LIN_INIT_CONFIG,
    ) -> CHANNEL_HANDLE;
}
extern "C" {
    pub fn ZCAN_StartLIN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ResetLIN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_TransmitLIN(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_MSG,
        Len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetLINReceiveNum(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReceiveLIN(
        channel_handle: CHANNEL_HANDLE,
        pReceive: PZCAN_LIN_MSG,
        Len: UINT,
        WaitTime: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetLINSubscribe(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_SUBSCIBE_CFG,
        nSubscribeCount: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetLINPublish(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_PUBLISH_CFG,
        nPublishCount: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetLINPublishEx(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_PUBLISH_CFG_EX,
        nPublishCount: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_WakeUpLIN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    #[doc = " @brief UDS诊断请求 (DoCAN)\n @param[in] device_handle 设备句柄\n @param[in] req 请求信息\n @param[out] resp 响应信息，可为nullptr，表示不关心响应数据\n @param[out] dataBuf\n 响应数据缓存区，存放积极响应的诊断数据(不包含SID)，实际长度为resp.positive.data_len\n @param[in] dataBufSize 响应数据缓存区总大小，如果小于响应诊断数据长度，返回\n STATUS_BUFFER_TOO_SMALL\n @return 执行结果状态"]
    pub fn ZCAN_UDS_Request(
        device_handle: DEVICE_HANDLE,
        req: *const ZCAN_UDS_REQUEST,
        resp: *mut ZCAN_UDS_RESPONSE,
        dataBuf: *mut BYTE,
        dataBufSize: UINT,
    ) -> ZCAN_RET_STATUS;
}
extern "C" {
    #[doc = " @brief UDS诊断控制, 如停止正在执行的UDS请求 (DoCAN)\n @param[in] device_handle 设备句柄\n @param[in] ctrl 控制请求信息\n @param[out] resp 响应信息，可为nullptr，表示不关心响应数据\n @return 执行结果状态"]
    pub fn ZCAN_UDS_Control(
        device_handle: DEVICE_HANDLE,
        ctrl: *const ZCAN_UDS_CTRL_REQ,
        resp: *mut ZCAN_UDS_CTRL_RESP,
    ) -> ZCAN_RET_STATUS;
}
extern "C" {
    #[doc = " @brief UDS诊断请求(总)\n @param[in] device_handle 设备句柄\n @param[in] requestData 请求信息\n @param[out] resp 响应信息，可为nullptr，表示不关心响应数据\n @param[out] dataBuf\n 响应数据缓存区，存放积极响应的诊断数据(不包含SID)，实际长度为resp.positive.data_len\n @param[in] dataBufSize 响应数据缓存区总大小，如果小于响应诊断数据长度，返回\n STATUS_BUFFER_TOO_SMALL"]
    pub fn ZCAN_UDS_RequestEX(
        device_handle: DEVICE_HANDLE,
        requestData: *const ZCANUdsRequestDataObj,
        resp: *mut ZCAN_UDS_RESPONSE,
        dataBuf: *mut BYTE,
        dataBufSize: UINT,
    ) -> ZCAN_RET_STATUS;
}
extern "C" {
    #[doc = " @brief UDS诊断控制，如停止正在执行的UDS请求(总)\n @param[in] device_handle 设备句柄\n @param[in] dataType 数据类型\n @param[in] ctrl 控制请求信息\n @param[out] resp 响应信息，可为nullptr，表示不关心响应数据\n @return 执行结果状态"]
    pub fn ZCAN_UDS_ControlEX(
        device_handle: DEVICE_HANDLE,
        dataType: ZCAN_UDS_DATA_DEF,
        ctrl: *const ZCAN_UDS_CTRL_REQ,
        resp: *mut ZCAN_UDS_CTRL_RESP,
    ) -> ZCAN_RET_STATUS;
}
extern "C" {
    pub fn ZCAN_SetLINSlaveMsg(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_MSG,
        nMsgCount: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ClearLINSlaveMsg(
        channel_handle: CHANNEL_HANDLE,
        pLINID: *mut BYTE,
        nIDCount: UINT,
    ) -> UINT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
