/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const ZCAN_CMD_SET_CHNL_RECV_MERGE: u32 = 50;
pub const ZCAN_CMD_GET_CHNL_RECV_MERGE: u32 = 51;
pub const ZCAN_UDS_TRANS_VER_0: u32 = 0;
pub const ZCAN_UDS_TRANS_VER_1: u32 = 1;
pub const ZCAN_UDS_FRAME_CAN: u32 = 0;
pub const ZCAN_UDS_FRAME_CANFD: u32 = 1;
pub const ZCAN_UDS_FRAME_CANFD_BRS: u32 = 2;
pub const ZCAN_UDS_ERROR_OK: u32 = 0;
pub const ZCAN_UDS_ERROR_TIMEOUT: u32 = 1;
pub const ZCAN_UDS_ERROR_TRANSPORT: u32 = 2;
pub const ZCAN_UDS_ERROR_CANCEL: u32 = 3;
pub const ZCAN_UDS_ERROR_SUPPRESS_RESPONSE: u32 = 4;
pub const ZCAN_UDS_ERROR_BUSY: u32 = 5;
pub const ZCAN_UDS_ERROR_REQ_PARAM: u32 = 6;
pub const ZCAN_UDS_ERROR_OTHTER: u32 = 100;
pub const ZCAN_UDS_RT_NEGATIVE: u32 = 0;
pub const ZCAN_UDS_RT_POSITIVE: u32 = 1;
pub const ZCAN_UDS_CTRL_STOP_REQ: u32 = 0;
pub const ZCAN_UDS_CTRL_RESULT_OK: u32 = 0;
pub const ZCAN_UDS_CTRL_RESULT_ERR: u32 = 1;
pub type U8 = ::core::ffi::c_uchar;
pub type U16 = ::core::ffi::c_ushort;
pub type U32 = ::core::ffi::c_uint;
pub type U64 = ::core::ffi::c_ulonglong;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_CAN_DATA: eZCANDataDEF = 1;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_CANFD_DATA: eZCANDataDEF = 2;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_ERROR_DATA: eZCANDataDEF = 3;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_DATA: eZCANDataDEF = 4;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_ERROR_DATA: eZCANDataDEF = 5;
pub type eZCANDataDEF = ::core::ffi::c_uint;
#[doc = "< normal transmission"]
pub const ZCAN_TX_MODE_ZCAN_TX_NORM: ZCAN_TX_MODE = 0;
#[doc = "< single-shot transmission"]
pub const ZCAN_TX_MODE_ZCAN_TX_ONCE: ZCAN_TX_MODE = 1;
#[doc = "< self reception"]
pub const ZCAN_TX_MODE_ZCAN_SR_NORM: ZCAN_TX_MODE = 2;
#[doc = "< single-shot transmission & self reception"]
pub const ZCAN_TX_MODE_ZCAN_SR_ONCE: ZCAN_TX_MODE = 3;
pub type ZCAN_TX_MODE = ::core::ffi::c_uint;
#[doc = " CAN filter configuration"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_FILTER {
    #[doc = "< 0-std_frame, 1-ext_frame"]
    pub type_: U8,
    pub pad: [U8; 3usize],
    #[doc = "< start-id"]
    pub sid: U32,
    #[doc = "< end-id"]
    pub eid: U32,
}
#[doc = " controller initialization"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_INIT {
    #[doc = "< clock(Hz)"]
    pub clk: U32,
    #[doc = "< bit0-normal/listen_only, bit1-ISO/BOSCH"]
    pub mode: U32,
    pub aset: ZCAN_INIT__bindgen_ty_1,
    pub dset: ZCAN_INIT__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_INIT__bindgen_ty_1 {
    pub tseg1: U8,
    pub tseg2: U8,
    pub sjw: U8,
    pub smp: U8,
    pub brp: U16,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_INIT__bindgen_ty_2 {
    pub tseg1: U8,
    pub tseg2: U8,
    pub sjw: U8,
    pub smp: U8,
    pub brp: U16,
}
#[doc = " CAN message info"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_MSG_INF {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl ZCAN_MSG_INF {
    #[inline]
    pub fn txm(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_txm(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fmt(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn sdf(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sdf(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sef(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sef(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn err(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_err(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brs(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brs(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn est(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_est(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> U32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: U32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        txm: U32,
        fmt: U32,
        sdf: U32,
        sef: U32,
        err: U32,
        brs: U32,
        est: U32,
        pad: U32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let txm: u32 = unsafe { ::core::mem::transmute(txm) };
            txm as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let fmt: u32 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let sdf: u32 = unsafe { ::core::mem::transmute(sdf) };
            sdf as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sef: u32 = unsafe { ::core::mem::transmute(sef) };
            sef as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let err: u32 = unsafe { ::core::mem::transmute(err) };
            err as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let brs: u32 = unsafe { ::core::mem::transmute(brs) };
            brs as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let est: u32 = unsafe { ::core::mem::transmute(est) };
            est as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let pad: u32 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " CAN message header"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_MSG_HDR {
    #[doc = "< timestamp"]
    pub ts: U32,
    #[doc = "< CAN-ID"]
    pub id: U32,
    #[doc = "< @see ZCAN_MSG_INF"]
    pub inf: ZCAN_MSG_INF,
    pub pad: U16,
    #[doc = "< channel"]
    pub chn: U8,
    #[doc = "< data length"]
    pub len: U8,
}
#[doc = " CAN2.0-frame"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_20_MSG {
    pub hdr: ZCAN_MSG_HDR,
    pub dat: [U8; 8usize],
}
#[doc = " CANFD-frame"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ZCAN_FD_MSG {
    pub hdr: ZCAN_MSG_HDR,
    pub dat: [U8; 64usize],
}
impl Default for ZCAN_FD_MSG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " CANERR-frame"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_ERR_MSG {
    pub hdr: ZCAN_MSG_HDR,
    pub dat: [U8; 8usize],
}
#[doc = " device info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ZCAN_DEV_INF {
    #[doc = "< hardware version"]
    pub hwv: U16,
    #[doc = "< firmware version"]
    pub fwv: U16,
    #[doc = "< driver version"]
    pub drv: U16,
    #[doc = "< API version"]
    pub api: U16,
    #[doc = "< IRQ"]
    pub irq: U16,
    #[doc = "< channels"]
    pub chn: U8,
    #[doc = "< serial number"]
    pub sn: [U8; 20usize],
    #[doc = "< card id"]
    pub id: [U8; 40usize],
    pub pad: [U16; 4usize],
}
impl Default for ZCAN_DEV_INF {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " controller status"]
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ZCAN_STAT {
    #[doc = "< not used(for backward compatibility)"]
    pub IR: U8,
    #[doc = "< not used"]
    pub MOD: U8,
    #[doc = "< not used"]
    pub SR: U8,
    #[doc = "< not used"]
    pub ALC: U8,
    #[doc = "< not used"]
    pub ECC: U8,
    #[doc = "< not used"]
    pub EWL: U8,
    #[doc = "< RX errors"]
    pub RXE: U8,
    #[doc = "< TX errors"]
    pub TXE: U8,
    pub PAD: U32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_INIT_CONFIG {
    pub linMode: U8,
    pub chkSumMode: U8,
    pub reserved: U16,
    pub linBaud: U32,
}
pub type ZCAN_LIN_INIT_CONFIG = _VCI_LIN_INIT_CONFIG;
pub type PZCAN_LIN_INIT_CONFIG = *mut _VCI_LIN_INIT_CONFIG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCANLINData {
    pub PID: tagZCANLINData__bindgen_ty_1,
    pub RxData: tagZCANLINData__bindgen_ty_2,
    pub reserved: [U8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANLINData__bindgen_ty_1 {
    pub unionVal: tagZCANLINData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: U8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tagZCANLINData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> U8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: U8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Parity(&self) -> U8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Parity(&mut self, val: U8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: U8, Parity: U8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Parity: u8 = unsafe { ::core::mem::transmute(Parity) };
            Parity as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINData__bindgen_ty_2 {
    pub timeStamp: U64,
    pub dataLen: U8,
    pub dir: U8,
    pub chkSum: U8,
    pub reserved: [U8; 13usize],
    pub data: [U8; 8usize],
}
impl Default for tagZCANLINData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINData = tagZCANLINData;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANLINErrData {
    pub timeStamp: U64,
    pub PID: tagZCANLINErrData__bindgen_ty_1,
    pub dataLen: U8,
    pub data: [U8; 8usize],
    pub errData: tagZCANLINErrData__bindgen_ty_2,
    pub dir: U8,
    pub chkSum: U8,
    pub reserved: [U8; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANLINErrData__bindgen_ty_1 {
    pub unionVal: tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: U8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> U8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: U8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Parity(&self) -> U8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Parity(&mut self, val: U8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: U8, Parity: U8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Parity: u8 = unsafe { ::core::mem::transmute(Parity) };
            Parity as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINErrData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANLINErrData__bindgen_ty_2 {
    pub __bindgen_anon_1: tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1,
    pub unionErrData: U16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn errStage(&self) -> U16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_errStage(&mut self, val: U16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn errReason(&self) -> U16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_errReason(&mut self, val: U16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> U16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: U16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        errStage: U16,
        errReason: U16,
        reserved: U16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let errStage: u16 = unsafe { ::core::mem::transmute(errStage) };
            errStage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let errReason: u16 = unsafe { ::core::mem::transmute(errReason) };
            errReason as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINErrData__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANLINErrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINErrData = tagZCANLINErrData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VCI_LIN_MSG {
    pub chnl: U8,
    pub dataType: U8,
    pub data: _VCI_LIN_MSG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VCI_LIN_MSG__bindgen_ty_1 {
    pub zcanLINData: ZCANLINData,
    pub zcanLINErrData: ZCANLINErrData,
    pub raw: [U8; 46usize],
}
impl Default for _VCI_LIN_MSG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VCI_LIN_MSG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_LIN_MSG = _VCI_LIN_MSG;
pub type PZCAN_LIN_MSG = *mut _VCI_LIN_MSG;
pub const eZLINChkSumMode_DEFAULT: eZLINChkSumMode = 0;
pub const eZLINChkSumMode_CLASSIC_CHKSUM: eZLINChkSumMode = 1;
pub const eZLINChkSumMode_ENHANCE_CHKSUM: eZLINChkSumMode = 2;
pub const eZLINChkSumMode_AUTOMATIC: eZLINChkSumMode = 3;
pub type eZLINChkSumMode = ::core::ffi::c_uint;
pub const MAX_LIN_ID_COUNT: _bindgen_ty_1 = 63;
pub const MIN_LIN_DLC: _bindgen_ty_1 = 1;
pub const MAX_LIN_DLC: _bindgen_ty_1 = 8;
pub const AUTO_LIN_DLC: _bindgen_ty_1 = 255;
pub type _bindgen_ty_1 = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_PUBLISH_CFG {
    pub ID: U8,
    pub dataLen: U8,
    pub data: [U8; 8usize],
    pub chkSumMode: U8,
    pub reserved: [U8; 5usize],
}
pub type ZCAN_LIN_PUBLISH_CFG = _VCI_LIN_PUBLISH_CFG;
pub type PZCAN_LIN_PUBLISH_CFG = *mut _VCI_LIN_PUBLISH_CFG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_SUBSCIBE_CFG {
    pub ID: U8,
    pub dataLen: U8,
    pub chkSumMode: U8,
    pub reserved: [U8; 5usize],
}
pub type ZCAN_LIN_SUBSCIBE_CFG = _VCI_LIN_SUBSCIBE_CFG;
pub type PZCAN_LIN_SUBSCIBE_CFG = *mut _VCI_LIN_SUBSCIBE_CFG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCANDataObj {
    pub dataType: U8,
    pub chnl: U8,
    pub flag: tagZCANDataObj__bindgen_ty_1,
    pub extraData: [U8; 4usize],
    pub data: tagZCANDataObj__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANDataObj__bindgen_ty_1 {
    pub unionVal: tagZCANDataObj__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: U16,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANDataObj__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tagZCANDataObj__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved(&self) -> U16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: U16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved: U16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANDataObj__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANDataObj__bindgen_ty_2 {
    pub zcanCANData: ZCAN_20_MSG,
    pub zcanCANFDData: ZCAN_FD_MSG,
    pub zcanErrData: ZCAN_ERR_MSG,
    pub zcanLINData: ZCANLINData,
    pub zcanLINErrData: ZCANLINErrData,
    pub raw: [U8; 92usize],
}
impl Default for tagZCANDataObj__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANDataObj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANDataObj = tagZCANDataObj;
pub type ZCAN_UDS_TRANS_VER = U8;
pub type ZCAN_UDS_FRAME_TYPE = U8;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST {
    pub req_id: U32,
    pub channel: U8,
    pub frame_type: ZCAN_UDS_FRAME_TYPE,
    pub reserved0: [U8; 2usize],
    pub src_addr: U32,
    pub dst_addr: U32,
    pub suppress_response: U8,
    pub sid: U8,
    pub reserved1: [U8; 6usize],
    pub session_param: _ZCAN_UDS_REQUEST__bindgen_ty_1,
    pub trans_param: _ZCAN_UDS_REQUEST__bindgen_ty_2,
    pub data: *mut U8,
    pub data_len: U32,
    pub reserved2: U32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST__bindgen_ty_1 {
    pub timeout: U32,
    pub enhanced_timeout: U32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved0: [U8; 7usize],
}
impl _ZCAN_UDS_REQUEST__bindgen_ty_1 {
    #[inline]
    pub fn check_any_negative_response(&self) -> U8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_check_any_negative_response(&mut self, val: U8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_if_suppress_response(&self) -> U8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_if_suppress_response(&mut self, val: U8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag(&self) -> U8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag(&mut self, val: U8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        check_any_negative_response: U8,
        wait_if_suppress_response: U8,
        flag: U8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let check_any_negative_response: u8 =
                unsafe { ::core::mem::transmute(check_any_negative_response) };
            check_any_negative_response as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wait_if_suppress_response: u8 =
                unsafe { ::core::mem::transmute(wait_if_suppress_response) };
            wait_if_suppress_response as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag: u8 = unsafe { ::core::mem::transmute(flag) };
            flag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST__bindgen_ty_2 {
    pub version: ZCAN_UDS_TRANS_VER,
    pub max_data_len: U8,
    pub local_st_min: U8,
    pub block_size: U8,
    pub fill_byte: U8,
    pub ext_frame: U8,
    pub is_modify_ecu_st_min: U8,
    pub remote_st_min: U8,
    pub fc_timeout: U32,
    pub reserved0: [U8; 4usize],
}
impl Default for _ZCAN_UDS_REQUEST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_UDS_REQUEST = _ZCAN_UDS_REQUEST;
pub type ZCAN_UDS_ERROR = U8;
pub type ZCAN_UDS_RESPONSE_TYPE = U8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE {
    pub status: ZCAN_UDS_ERROR,
    pub reserved: [U8; 6usize],
    pub type_: ZCAN_UDS_RESPONSE_TYPE,
    pub __bindgen_anon_1: _ZCAN_UDS_RESPONSE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ZCAN_UDS_RESPONSE__bindgen_ty_1 {
    pub positive: _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_1,
    pub negative: _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_2,
    pub raw: [U8; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_1 {
    pub sid: U8,
    pub data_len: U32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_2 {
    pub neg_code: U8,
    pub sid: U8,
    pub error_code: U8,
}
impl Default for _ZCAN_UDS_RESPONSE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ZCAN_UDS_RESPONSE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_UDS_RESPONSE = _ZCAN_UDS_RESPONSE;
pub type ZCAN_UDS_CTRL_CODE = U32;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_CTRL_REQ {
    pub reqID: U32,
    pub cmd: ZCAN_UDS_CTRL_CODE,
    pub reserved: [U8; 8usize],
}
pub type ZCAN_UDS_CTRL_REQ = _ZCAN_UDS_CTRL_REQ;
pub type ZCAN_UDS_CTRL_RESULT = U32;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_CTRL_RESP {
    pub result: ZCAN_UDS_CTRL_RESULT,
    pub reserved: [U8; 8usize],
}
pub type ZCAN_UDS_CTRL_RESP = _ZCAN_UDS_CTRL_RESP;
extern "C" {
    pub fn VCI_OpenDevice(Type: U32, Card: U32, Reserved: U32) -> U32;
}
extern "C" {
    pub fn VCI_CloseDevice(Type: U32, Card: U32) -> U32;
}
extern "C" {
    pub fn VCI_InitCAN(Type: U32, Card: U32, Port: U32, pInit: *mut ZCAN_INIT) -> U32;
}
extern "C" {
    pub fn VCI_ReadBoardInfo(Type: U32, Card: U32, pInfo: *mut ZCAN_DEV_INF) -> U32;
}
extern "C" {
    pub fn VCI_ReadErrInfo(Type: U32, Card: U32, Port: U32, pErr: *mut ZCAN_ERR_MSG) -> U32;
}
extern "C" {
    pub fn VCI_ReadCANStatus(Type: U32, Card: U32, Port: U32, pStat: *mut ZCAN_STAT) -> U32;
}
extern "C" {
    pub fn VCI_GetReference(
        Type: U32,
        Card: U32,
        Port: U32,
        Ref: U32,
        pData: *mut ::core::ffi::c_void,
    ) -> U32;
}
extern "C" {
    pub fn VCI_SetReference(
        Type: U32,
        Card: U32,
        Port: U32,
        Ref: U32,
        pData: *mut ::core::ffi::c_void,
    ) -> U32;
}
extern "C" {
    pub fn VCI_GetReceiveNum(Type: U32, Card: U32, Port: U32) -> U32;
}
extern "C" {
    pub fn VCI_ClearBuffer(Type: U32, Card: U32, Port: U32) -> U32;
}
extern "C" {
    pub fn VCI_StartCAN(Type: U32, Card: U32, Port: U32) -> U32;
}
extern "C" {
    pub fn VCI_ResetCAN(Type: U32, Card: U32, Port: U32) -> U32;
}
extern "C" {
    pub fn VCI_Transmit(
        Type: U32,
        Card: U32,
        Port: U32,
        pData: *mut ZCAN_20_MSG,
        Count: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_TransmitFD(
        Type: U32,
        Card: U32,
        Port: U32,
        pData: *mut ZCAN_FD_MSG,
        Count: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_Receive(
        Type: U32,
        Card: U32,
        Port: U32,
        pData: *mut ZCAN_20_MSG,
        Count: U32,
        Time: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_ReceiveFD(
        Type: U32,
        Card: U32,
        Port: U32,
        pData: *mut ZCAN_FD_MSG,
        Count: U32,
        Time: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_Debug(Debug: U32) -> U32;
}
extern "C" {
    pub fn VCI_InitLIN(
        Type: U32,
        Card: U32,
        LinChn: U32,
        pLINInitConfig: PZCAN_LIN_INIT_CONFIG,
    ) -> U32;
}
extern "C" {
    pub fn VCI_StartLIN(Type: U32, Card: U32, LinChn: U32) -> U32;
}
extern "C" {
    pub fn VCI_ResetLIN(Type: U32, Card: U32, LinChn: U32) -> U32;
}
extern "C" {
    pub fn VCI_TransmitLIN(
        Type: U32,
        Card: U32,
        LinChn: U32,
        pSend: PZCAN_LIN_MSG,
        Len: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_GetLINReceiveNum(Type: U32, Card: U32, LinChn: U32) -> U32;
}
extern "C" {
    pub fn VCI_ClearLINBuffer(Type: U32, Card: U32, LinChn: U32) -> U32;
}
extern "C" {
    pub fn VCI_ReceiveLIN(
        Type: U32,
        Card: U32,
        LinChn: U32,
        pReceive: PZCAN_LIN_MSG,
        Len: U32,
        WaitTime: ::core::ffi::c_int,
    ) -> U32;
}
extern "C" {
    pub fn VCI_SetLINSubscribe(
        Type: U32,
        Card: U32,
        LinChn: U32,
        pSend: PZCAN_LIN_SUBSCIBE_CFG,
        nSubscribeCount: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_SetLINPublish(
        Type: U32,
        Card: U32,
        LinChn: U32,
        pSend: PZCAN_LIN_PUBLISH_CFG,
        nPublishCount: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_TransmitData(
        Type: ::core::ffi::c_uint,
        Card: ::core::ffi::c_uint,
        Port: ::core::ffi::c_uint,
        pData: *mut ZCANDataObj,
        Count: ::core::ffi::c_uint,
    ) -> U32;
}
extern "C" {
    pub fn VCI_ReceiveData(
        Type: ::core::ffi::c_uint,
        Card: ::core::ffi::c_uint,
        Port: ::core::ffi::c_uint,
        pData: *mut ZCANDataObj,
        Count: ::core::ffi::c_uint,
        Time: ::core::ffi::c_uint,
    ) -> U32;
}
extern "C" {
    pub fn VCI_UDS_Request(
        Type: ::core::ffi::c_uint,
        Card: ::core::ffi::c_uint,
        req: *const ZCAN_UDS_REQUEST,
        resp: *mut ZCAN_UDS_RESPONSE,
        dataBuf: *mut U8,
        dataBufSize: U32,
    ) -> U32;
}
extern "C" {
    pub fn VCI_UDS_Control(
        Type: ::core::ffi::c_uint,
        Card: ::core::ffi::c_uint,
        ctrl: *const ZCAN_UDS_CTRL_REQ,
        resp: *mut ZCAN_UDS_CTRL_RESP,
    ) -> U32;
}
