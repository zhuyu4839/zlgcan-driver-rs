/* automatically generated by rust-bindgen 0.69.4 */

pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const CAN_EFF_FLAG: u32 = 2147483648;
pub const CAN_RTR_FLAG: u32 = 1073741824;
pub const CAN_ERR_FLAG: u32 = 536870912;
pub const CAN_ID_FLAG: u32 = 536870911;
pub const CAN_SFF_MASK: u32 = 2047;
pub const CAN_EFF_MASK: u32 = 536870911;
pub const CAN_ERR_MASK: u32 = 536870911;
pub const CAN_SFF_ID_BITS: u32 = 11;
pub const CAN_EFF_ID_BITS: u32 = 29;
pub const CAN_MAX_DLC: u32 = 8;
pub const CAN_MAX_DLEN: u32 = 8;
pub const CANFD_MAX_DLC: u32 = 15;
pub const CANFD_MAX_DLEN: u32 = 64;
pub const CANFD_BRS: u32 = 1;
pub const CANFD_ESI: u32 = 2;
pub const ZCAN_PCI5121: u32 = 1;
pub const ZCAN_PCI9810: u32 = 2;
pub const ZCAN_USBCAN1: u32 = 3;
pub const ZCAN_USBCAN2: u32 = 4;
pub const ZCAN_USBCAN2A: u32 = 4;
pub const ZCAN_PCI9820: u32 = 5;
pub const ZCAN_CAN232: u32 = 6;
pub const ZCAN_PCI5110: u32 = 7;
pub const ZCAN_CANLITE: u32 = 8;
pub const ZCAN_ISA9620: u32 = 9;
pub const ZCAN_ISA5420: u32 = 10;
pub const ZCAN_PC104CAN: u32 = 11;
pub const ZCAN_CANETUDP: u32 = 12;
pub const ZCAN_CANETE: u32 = 12;
pub const ZCAN_DNP9810: u32 = 13;
pub const ZCAN_PCI9840: u32 = 14;
pub const ZCAN_PC104CAN2: u32 = 15;
pub const ZCAN_PCI9820I: u32 = 16;
pub const ZCAN_CANETTCP: u32 = 17;
pub const ZCAN_PEC9920: u32 = 18;
pub const ZCAN_PCIE_9220: u32 = 18;
pub const ZCAN_PCI5010U: u32 = 19;
pub const ZCAN_USBCAN_E_U: u32 = 20;
pub const ZCAN_USBCAN_2E_U: u32 = 21;
pub const ZCAN_PCI5020U: u32 = 22;
pub const ZCAN_EG20T_CAN: u32 = 23;
pub const ZCAN_PCIE9221: u32 = 24;
pub const ZCAN_WIFICAN_TCP: u32 = 25;
pub const ZCAN_WIFICAN_UDP: u32 = 26;
pub const ZCAN_PCIe9120: u32 = 27;
pub const ZCAN_PCIe9110: u32 = 28;
pub const ZCAN_PCIe9140: u32 = 29;
pub const ZCAN_USBCAN_4E_U: u32 = 31;
pub const ZCAN_CANDTU: u32 = 32;
pub const ZCAN_CANDTU_MINI: u32 = 33;
pub const ZCAN_USBCAN_8E_U: u32 = 34;
pub const ZCAN_CANREPLAY: u32 = 35;
pub const ZCAN_CANDTU_NET: u32 = 36;
pub const ZCAN_CANDTU_100UR: u32 = 37;
pub const ZCAN_PCIE_CANFD_100U: u32 = 38;
pub const ZCAN_PCIE_CANFD_200U: u32 = 39;
pub const ZCAN_PCIE_CANFD_400U: u32 = 40;
pub const ZCAN_VIRTUAL_DEVICE: u32 = 99;
pub const ERR_CAN_OVERFLOW: u32 = 1;
pub const ERR_CAN_ERRALARM: u32 = 2;
pub const ERR_CAN_PASSIVE: u32 = 4;
pub const ERR_CAN_LOSE: u32 = 8;
pub const ERR_CAN_BUSERR: u32 = 16;
pub const ERR_CAN_BUSOFF: u32 = 32;
pub const ERR_CAN_BUFFER_OVERFLOW: u32 = 64;
pub const ERR_DEVICEOPENED: u32 = 256;
pub const ERR_DEVICEOPEN: u32 = 512;
pub const ERR_DEVICENOTOPEN: u32 = 1024;
pub const ERR_BUFFEROVERFLOW: u32 = 2048;
pub const ERR_DEVICENOTEXIST: u32 = 4096;
pub const ERR_LOADKERNELDLL: u32 = 8192;
pub const ERR_CMDFAILED: u32 = 16384;
pub const ERR_BUFFERCREATE: u32 = 32768;
pub const ERR_CANETE_PORTOPENED: u32 = 65536;
pub const ERR_CANETE_INDEXUSED: u32 = 131072;
pub const ERR_REF_TYPE_ID: u32 = 196609;
pub const ERR_CREATE_SOCKET: u32 = 196610;
pub const ERR_OPEN_CONNECT: u32 = 196611;
pub const ERR_NO_STARTUP: u32 = 196612;
pub const ERR_NO_CONNECTED: u32 = 196613;
pub const ERR_SEND_PARTIAL: u32 = 196614;
pub const ERR_SEND_TOO_FAST: u32 = 196615;
pub const STATUS_OK: u32 = 1;
pub const STATUS_ERR: u32 = 0;
pub const CMD_DESIP: u32 = 0;
pub const CMD_DESPORT: u32 = 1;
pub const CMD_CHGDESIPANDPORT: u32 = 2;
pub const CMD_SRCPORT: u32 = 2;
pub const CMD_TCP_TYPE: u32 = 4;
pub const TCP_CLIENT: u32 = 0;
pub const TCP_SERVER: u32 = 1;
pub const CMD_CLIENT_COUNT: u32 = 5;
pub const CMD_CLIENT: u32 = 6;
pub const CMD_DISCONN_CLINET: u32 = 7;
pub const CMD_SET_RECONNECT_TIME: u32 = 8;
pub const TYPE_CAN: u32 = 0;
pub const TYPE_CANFD: u32 = 1;
pub const INVALID_DEVICE_HANDLE: u32 = 0;
pub const INVALID_CHANNEL_HANDLE: u32 = 0;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
    pub tm_gmtoff: ::core::ffi::c_long,
    pub tm_zone: *const ::core::ffi::c_char,
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::core::ffi::c_char,
        __maxsize: usize,
        __format: *const ::core::ffi::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::core::ffi::c_char,
        __maxsize: usize,
        __format: *const ::core::ffi::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::core::ffi::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::core::ffi::c_int;
}
extern "C" {
    pub static mut __timezone: ::core::ffi::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::core::ffi::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::core::ffi::c_int;
}
extern "C" {
    pub static mut timezone: ::core::ffi::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::core::ffi::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::core::ffi::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type __u32 = ::core::ffi::c_uint;
pub type __u8 = ::core::ffi::c_uchar;
pub type USHORT = ::core::ffi::c_ushort;
pub type CHAR = ::core::ffi::c_char;
pub type UCHAR = ::core::ffi::c_uchar;
pub type UINT = ::core::ffi::c_uint;
pub type canid_t = __u32;
pub type can_err_mask_t = __u32;
#[doc = " struct can_frame - basic CAN frame structure\n @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition\n @can_dlc: frame payload length in byte (0 .. 8) aka data length code\n           N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1\n           mapping of the 'data length code' to the real payload length\n @__pad:   padding\n @__res0:  reserved / padding\n @__res1:  reserved / padding\n @data:    CAN frame payload (up to 8 byte)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct can_frame {
    pub can_id: canid_t,
    pub can_dlc: __u8,
    pub __pad: __u8,
    pub __res0: __u8,
    pub __res1: __u8,
    pub data: [__u8; 8usize],
}
#[doc = " struct canfd_frame - CAN flexible data rate frame structure\n @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition\n @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)\n @flags:  additional flags for CAN FD\n @__res0: reserved / padding\n @__res1: reserved / padding\n @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct canfd_frame {
    pub can_id: canid_t,
    pub len: __u8,
    pub flags: __u8,
    pub __res0: __u8,
    pub __res1: __u8,
    pub data: [__u8; 64usize],
}
impl Default for canfd_frame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Meta\n �ڵ�mata��Ϣ��"]
pub type Meta = _Meta;
#[doc = "  \\struct Pair\n  ���Ե�KeyValue�ԡ�"]
pub type Pair = _Pair;
#[doc = "  \\struct Options\n �ڵ�mata�Ŀ�ѡ�\u{e863}"]
pub type Options = _Options;
#[doc = "  \\struct ConfigNode\n  ConfigNode"]
pub type ConfigNode = _ConfigNode;
#[doc = "  \\struct Options\n �ڵ�mata�Ŀ�ѡ�\u{e863}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Options {
    #[doc = " ��ѡ�����������"]
    pub type_: *const ::core::ffi::c_char,
    #[doc = " ��ѡ���\u{5b5}"]
    pub value: *const ::core::ffi::c_char,
    #[doc = " ��ѡ���������Ϣ"]
    pub desc: *const ::core::ffi::c_char,
}
impl Default for _Options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Meta\n �ڵ�mata��Ϣ��"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Meta {
    #[doc = " ���������������"]
    pub type_: *const ::core::ffi::c_char,
    #[doc = " �������˵������Ϣ"]
    pub desc: *const ::core::ffi::c_char,
    #[doc = " �������Ƿ���\u{5bb}���ģ�ȱʡΪ�ɶ�д"]
    pub read_only: ::core::ffi::c_int,
    #[doc = " �����������ʽ����ʾ"]
    pub format: *const ::core::ffi::c_char,
    #[doc = " ������\u{5b5}���͵���������˵����С\u{5b5}�����\u{5b7}�������������˵����С���ȣ��\u{5bd}�������"]
    pub min_value: f64,
    #[doc = " ������\u{5b5}���͵���������˵�����\u{5b5}�����\u{5b7}�������������˵����\u{f3936}ȣ��\u{5bd}�������"]
    pub max_value: f64,
    #[doc = " ������ĵ�λ"]
    pub unit: *const ::core::ffi::c_char,
    #[doc = " \u{368}����ť/���\u{5b5}ȷ�ʽ�\u{7b8}�������ʱ������"]
    pub delta: f64,
    #[doc = "���������Ƿ��ڽ����Ͽɼ�, 1�ɼ���0���ɼ���ȱʡ�ɼ�"]
    pub visible: ::core::ffi::c_int,
    #[doc = " ������Ŀ�ѡ\u{5b5}��������type��Ϊ�������ʱ��Ч"]
    pub editable: ::core::ffi::c_int,
    #[doc = " ������Ŀ�ѡ\u{5b5}��������type��Ϊ�������ʱ��Ч����NULL����"]
    pub options: *mut *mut Options,
}
impl Default for _Meta {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Pair\n  ���Ե�KeyValue�ԡ�"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pair {
    pub key: *const ::core::ffi::c_char,
    pub value: *const ::core::ffi::c_char,
}
impl Default for _Pair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct ConfigNode\n  ConfigNode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ConfigNode {
    #[doc = " �ڵ������"]
    pub name: *const ::core::ffi::c_char,
    #[doc = " �ڵ��\u{5b5}"]
    pub value: *const ::core::ffi::c_char,
    #[doc = " �ýڵ��·��"]
    pub path: *const ::core::ffi::c_char,
    #[doc = " ��������Ϣ"]
    pub meta_info: *mut Meta,
    #[doc = " �ýڵ���ӽڵ�, ��NULL����"]
    pub children: *mut *mut ConfigNode,
    #[doc = " �ýڵ������, ��NULL����"]
    pub attributes: *mut *mut Pair,
}
impl Default for _ConfigNode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief ��ȡ���Ե�������Ϣ��\n\n \\retval ConfigNode"]
pub type GetPropertysFunc = ::core::option::Option<unsafe extern "C" fn() -> *const ConfigNode>;
#[doc = " \\brief ����\u{5b8}��·�������Ե�\u{5b5}��\n \\param[in] path  : ���Ե�·����\n \\param[in] value : ���Ե�\u{5b5}��\n\n \\retval �ɹ�����1��ʧ�\u{737}���0��"]
pub type SetValueFunc = ::core::option::Option<
    unsafe extern "C" fn(
        path: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief ����\u{5b8}��·�������Ե�\u{5b5}��\n \\param[in] path  : ���Ե�·����\n\n \\retval �ɹ��������Ե�\u{5b5}��ʧ�\u{737}���NULL��"]
pub type GetValueFunc = ::core::option::Option<
    unsafe extern "C" fn(path: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagIProperty {
    pub SetValue: SetValueFunc,
    pub GetValue: GetValueFunc,
    pub GetPropertys: GetPropertysFunc,
}
pub type IProperty = tagIProperty;
pub type BYTE = ::core::ffi::c_uchar;
pub type UINT64 = ::core::ffi::c_ulonglong;
pub type INT = ::core::ffi::c_int;
pub type DEVICE_HANDLE = *mut ::core::ffi::c_void;
pub type CHANNEL_HANDLE = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_DEVICE_INFO {
    pub hw_Version: USHORT,
    pub fw_Version: USHORT,
    pub dr_Version: USHORT,
    pub in_Version: USHORT,
    pub irq_Num: USHORT,
    pub can_Num: BYTE,
    pub str_Serial_Num: [UCHAR; 20usize],
    pub str_hw_Type: [UCHAR; 40usize],
    pub reserved: [USHORT; 4usize],
}
impl Default for tagZCAN_DEVICE_INFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_DEVICE_INFO = tagZCAN_DEVICE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG {
    pub can_type: UINT,
    pub __bindgen_anon_1: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1 {
    pub can: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_1,
    pub canfd: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_1 {
    pub acc_code: UINT,
    pub acc_mask: UINT,
    pub reserved: UINT,
    pub filter: BYTE,
    pub timing0: BYTE,
    pub timing1: BYTE,
    pub mode: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_2 {
    pub acc_code: UINT,
    pub acc_mask: UINT,
    pub timing0: UINT,
    pub timing1: UINT,
    pub brp: UINT,
    pub filter: BYTE,
    pub mode: BYTE,
    pub pad: USHORT,
    pub reserved: UINT,
}
impl Default for tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCAN_CHANNEL_INIT_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_CHANNEL_INIT_CONFIG = tagZCAN_CHANNEL_INIT_CONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_ERR_INFO {
    pub error_code: UINT,
    pub passive_ErrData: [BYTE; 3usize],
    pub arLost_ErrData: BYTE,
}
pub type ZCAN_CHANNEL_ERR_INFO = tagZCAN_CHANNEL_ERR_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_STATUS {
    pub errInterrupt: BYTE,
    pub regMode: BYTE,
    pub regStatus: BYTE,
    pub regALCapture: BYTE,
    pub regECCapture: BYTE,
    pub regEWLimit: BYTE,
    pub regRECounter: BYTE,
    pub regTECounter: BYTE,
    pub Reserved: UINT,
}
pub type ZCAN_CHANNEL_STATUS = tagZCAN_CHANNEL_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_Transmit_Data {
    pub frame: can_frame,
    pub transmit_type: UINT,
}
pub type ZCAN_Transmit_Data = tagZCAN_Transmit_Data;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_Receive_Data {
    pub frame: can_frame,
    pub timestamp: UINT64,
}
pub type ZCAN_Receive_Data = tagZCAN_Receive_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_TransmitFD_Data {
    pub frame: canfd_frame,
    pub transmit_type: UINT,
}
impl Default for tagZCAN_TransmitFD_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_TransmitFD_Data = tagZCAN_TransmitFD_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_ReceiveFD_Data {
    pub frame: canfd_frame,
    pub timestamp: UINT64,
}
impl Default for tagZCAN_ReceiveFD_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_ReceiveFD_Data = tagZCAN_ReceiveFD_Data;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_AUTO_TRANSMIT_OBJ {
    pub enable: USHORT,
    pub index: USHORT,
    pub interval: UINT,
    pub obj: ZCAN_Transmit_Data,
}
pub type ZCAN_AUTO_TRANSMIT_OBJ = tagZCAN_AUTO_TRANSMIT_OBJ;
pub type PZCAN_AUTO_TRANSMIT_OBJ = *mut tagZCAN_AUTO_TRANSMIT_OBJ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCANFD_AUTO_TRANSMIT_OBJ {
    pub interval: UINT,
    pub obj: ZCAN_TransmitFD_Data,
}
impl Default for tagZCANFD_AUTO_TRANSMIT_OBJ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANFD_AUTO_TRANSMIT_OBJ = tagZCANFD_AUTO_TRANSMIT_OBJ;
pub type PZCANFD_AUTO_TRANSMIT_OBJ = *mut tagZCANFD_AUTO_TRANSMIT_OBJ;
extern "C" {
    pub fn ZCAN_OpenDevice(device_type: UINT, device_index: UINT, reserved: UINT) -> DEVICE_HANDLE;
}
extern "C" {
    pub fn ZCAN_CloseDevice(device_handle: DEVICE_HANDLE) -> INT;
}
extern "C" {
    pub fn ZCAN_GetDeviceInf(device_handle: DEVICE_HANDLE, pInfo: *mut ZCAN_DEVICE_INFO) -> INT;
}
extern "C" {
    pub fn ZCAN_InitCAN(
        device_handle: DEVICE_HANDLE,
        can_index: UINT,
        pInitConfig: *mut ZCAN_CHANNEL_INIT_CONFIG,
    ) -> CHANNEL_HANDLE;
}
extern "C" {
    pub fn ZCAN_StartCAN(channel_handle: CHANNEL_HANDLE) -> INT;
}
extern "C" {
    pub fn ZCAN_ResetCAN(channel_handle: CHANNEL_HANDLE) -> INT;
}
extern "C" {
    pub fn ZCAN_ClearBuffer(channel_handle: CHANNEL_HANDLE) -> INT;
}
extern "C" {
    pub fn ZCAN_ReadChannelErrInfo(
        channel_handle: CHANNEL_HANDLE,
        pErrInfo: *mut ZCAN_CHANNEL_ERR_INFO,
    ) -> INT;
}
extern "C" {
    pub fn ZCAN_ReadChannelStatus(
        channel_handle: CHANNEL_HANDLE,
        pCANStatus: *mut ZCAN_CHANNEL_STATUS,
    ) -> INT;
}
extern "C" {
    pub fn ZCAN_Transmit(
        channel_handle: CHANNEL_HANDLE,
        pTransmit: *mut ZCAN_Transmit_Data,
        len: UINT,
    ) -> INT;
}
extern "C" {
    pub fn ZCAN_GetReceiveNum(channel_handle: CHANNEL_HANDLE, type_: BYTE) -> INT;
}
extern "C" {
    pub fn ZCAN_Receive(
        channel_handle: CHANNEL_HANDLE,
        pReceive: *mut ZCAN_Receive_Data,
        len: UINT,
        wait_time: INT,
    ) -> INT;
}
extern "C" {
    pub fn ZCAN_TransmitFD(
        channel_handle: CHANNEL_HANDLE,
        pTransmit: *mut ZCAN_TransmitFD_Data,
        len: UINT,
    ) -> INT;
}
extern "C" {
    pub fn ZCAN_ReceiveFD(
        channel_handle: CHANNEL_HANDLE,
        pReceive: *mut ZCAN_ReceiveFD_Data,
        len: UINT,
        wait_time: INT,
    ) -> INT;
}
extern "C" {
    pub fn GetIProperty(device_handle: DEVICE_HANDLE) -> *mut IProperty;
}
extern "C" {
    pub fn ReleaseIProperty(pIProperty: *mut IProperty) -> INT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
