/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const TIME_UTC: u32 = 1;
pub const CAN_EFF_FLAG: u32 = 2147483648;
pub const CAN_RTR_FLAG: u32 = 1073741824;
pub const CAN_ERR_FLAG: u32 = 536870912;
pub const CAN_ID_FLAG: u32 = 536870911;
pub const CAN_SFF_MASK: u32 = 2047;
pub const CAN_EFF_MASK: u32 = 536870911;
pub const CAN_ERR_MASK: u32 = 536870911;
pub const CAN_SFF_ID_BITS: u32 = 11;
pub const CAN_EFF_ID_BITS: u32 = 29;
pub const CAN_MAX_DLC: u32 = 8;
pub const CAN_MAX_DLEN: u32 = 8;
pub const CANFD_MAX_DLC: u32 = 15;
pub const CANFD_MAX_DLEN: u32 = 64;
pub const TX_DELAY_SEND_FLAG: u32 = 128;
pub const TX_DELAY_SEND_TIME_UNIT_FLAG: u32 = 64;
pub const TX_ECHO_FLAG: u32 = 32;
pub const CANFD_BRS: u32 = 1;
pub const CANFD_ESI: u32 = 2;
pub const ZCAN_PCI5121: u32 = 1;
pub const ZCAN_PCI9810: u32 = 2;
pub const ZCAN_USBCAN1: u32 = 3;
pub const ZCAN_USBCAN2: u32 = 4;
pub const ZCAN_PCI9820: u32 = 5;
pub const ZCAN_CAN232: u32 = 6;
pub const ZCAN_PCI5110: u32 = 7;
pub const ZCAN_CANLITE: u32 = 8;
pub const ZCAN_ISA9620: u32 = 9;
pub const ZCAN_ISA5420: u32 = 10;
pub const ZCAN_PC104CAN: u32 = 11;
pub const ZCAN_CANETUDP: u32 = 12;
pub const ZCAN_CANETE: u32 = 12;
pub const ZCAN_DNP9810: u32 = 13;
pub const ZCAN_PCI9840: u32 = 14;
pub const ZCAN_PC104CAN2: u32 = 15;
pub const ZCAN_PCI9820I: u32 = 16;
pub const ZCAN_CANETTCP: u32 = 17;
pub const ZCAN_PCIE_9220: u32 = 18;
pub const ZCAN_PCI5010U: u32 = 19;
pub const ZCAN_USBCAN_E_U: u32 = 20;
pub const ZCAN_USBCAN_2E_U: u32 = 21;
pub const ZCAN_PCI5020U: u32 = 22;
pub const ZCAN_EG20T_CAN: u32 = 23;
pub const ZCAN_PCIE9221: u32 = 24;
pub const ZCAN_WIFICAN_TCP: u32 = 25;
pub const ZCAN_WIFICAN_UDP: u32 = 26;
pub const ZCAN_PCIe9120: u32 = 27;
pub const ZCAN_PCIe9110: u32 = 28;
pub const ZCAN_PCIe9140: u32 = 29;
pub const ZCAN_USBCAN_4E_U: u32 = 31;
pub const ZCAN_CANDTU_200UR: u32 = 32;
pub const ZCAN_CANDTU_MINI: u32 = 33;
pub const ZCAN_USBCAN_8E_U: u32 = 34;
pub const ZCAN_CANREPLAY: u32 = 35;
pub const ZCAN_CANDTU_NET: u32 = 36;
pub const ZCAN_CANDTU_100UR: u32 = 37;
pub const ZCAN_PCIE_CANFD_100U: u32 = 38;
pub const ZCAN_PCIE_CANFD_200U: u32 = 39;
pub const ZCAN_PCIE_CANFD_400U: u32 = 40;
pub const ZCAN_USBCANFD_200U: u32 = 41;
pub const ZCAN_USBCANFD_100U: u32 = 42;
pub const ZCAN_USBCANFD_MINI: u32 = 43;
pub const ZCAN_CANFDCOM_100IE: u32 = 44;
pub const ZCAN_CANSCOPE: u32 = 45;
pub const ZCAN_CLOUD: u32 = 46;
pub const ZCAN_CANDTU_NET_400: u32 = 47;
pub const ZCAN_CANFDNET_TCP: u32 = 48;
pub const ZCAN_CANFDNET_200U_TCP: u32 = 48;
pub const ZCAN_CANFDNET_UDP: u32 = 49;
pub const ZCAN_CANFDNET_200U_UDP: u32 = 49;
pub const ZCAN_CANFDWIFI_TCP: u32 = 50;
pub const ZCAN_CANFDWIFI_100U_TCP: u32 = 50;
pub const ZCAN_CANFDWIFI_UDP: u32 = 51;
pub const ZCAN_CANFDWIFI_100U_UDP: u32 = 51;
pub const ZCAN_CANFDNET_400U_TCP: u32 = 52;
pub const ZCAN_CANFDNET_400U_UDP: u32 = 53;
pub const ZCAN_CANFDBLUE_200U: u32 = 54;
pub const ZCAN_CANFDNET_100U_TCP: u32 = 55;
pub const ZCAN_CANFDNET_100U_UDP: u32 = 56;
pub const ZCAN_CANFDNET_800U_TCP: u32 = 57;
pub const ZCAN_CANFDNET_800U_UDP: u32 = 58;
pub const ZCAN_USBCANFD_800U: u32 = 59;
pub const ZCAN_PCIE_CANFD_100U_EX: u32 = 60;
pub const ZCAN_PCIE_CANFD_400U_EX: u32 = 61;
pub const ZCAN_PCIE_CANFD_200U_MINI: u32 = 62;
pub const ZCAN_PCIE_CANFD_200U_M2: u32 = 63;
pub const ZCAN_CANFDDTU_400_TCP: u32 = 64;
pub const ZCAN_CANFDDTU_400_UDP: u32 = 65;
pub const ZCAN_CANFDWIFI_200U_TCP: u32 = 66;
pub const ZCAN_CANFDWIFI_200U_UDP: u32 = 67;
pub const ZCAN_CANFDDTU_800ER_TCP: u32 = 68;
pub const ZCAN_CANFDDTU_800ER_UDP: u32 = 69;
pub const ZCAN_CANFDDTU_800EWGR_TCP: u32 = 70;
pub const ZCAN_CANFDDTU_800EWGR_UDP: u32 = 71;
pub const ZCAN_CANFDDTU_600EWGR_TCP: u32 = 72;
pub const ZCAN_CANFDDTU_600EWGR_UDP: u32 = 73;
pub const ZCAN_CANFDDTU_CASCADE_TCP: u32 = 74;
pub const ZCAN_CANFDDTU_CASCADE_UDP: u32 = 75;
pub const ZCAN_USBCANFD_400U: u32 = 76;
pub const ZCAN_OFFLINE_DEVICE: u32 = 98;
pub const ZCAN_VIRTUAL_DEVICE: u32 = 99;
pub const ZCAN_ERROR_CAN_OVERFLOW: u32 = 1;
pub const ZCAN_ERROR_CAN_ERRALARM: u32 = 2;
pub const ZCAN_ERROR_CAN_PASSIVE: u32 = 4;
pub const ZCAN_ERROR_CAN_LOSE: u32 = 8;
pub const ZCAN_ERROR_CAN_BUSERR: u32 = 16;
pub const ZCAN_ERROR_CAN_BUSOFF: u32 = 32;
pub const ZCAN_ERROR_CAN_BUFFER_OVERFLOW: u32 = 64;
pub const ZCAN_ERROR_DEVICEOPENED: u32 = 256;
pub const ZCAN_ERROR_DEVICEOPEN: u32 = 512;
pub const ZCAN_ERROR_DEVICENOTOPEN: u32 = 1024;
pub const ZCAN_ERROR_BUFFEROVERFLOW: u32 = 2048;
pub const ZCAN_ERROR_DEVICENOTEXIST: u32 = 4096;
pub const ZCAN_ERROR_LOADKERNELDLL: u32 = 8192;
pub const ZCAN_ERROR_CMDFAILED: u32 = 16384;
pub const ZCAN_ERROR_BUFFERCREATE: u32 = 32768;
pub const ZCAN_ERROR_CANETE_PORTOPENED: u32 = 65536;
pub const ZCAN_ERROR_CANETE_INDEXUSED: u32 = 131072;
pub const ZCAN_ERROR_REF_TYPE_ID: u32 = 196609;
pub const ZCAN_ERROR_CREATE_SOCKET: u32 = 196610;
pub const ZCAN_ERROR_OPEN_CONNECT: u32 = 196611;
pub const ZCAN_ERROR_NO_STARTUP: u32 = 196612;
pub const ZCAN_ERROR_NO_CONNECTED: u32 = 196613;
pub const ZCAN_ERROR_SEND_PARTIAL: u32 = 196614;
pub const ZCAN_ERROR_SEND_TOO_FAST: u32 = 196615;
pub const STATUS_ERR: u32 = 0;
pub const STATUS_OK: u32 = 1;
pub const STATUS_ONLINE: u32 = 2;
pub const STATUS_OFFLINE: u32 = 3;
pub const STATUS_UNSUPPORTED: u32 = 4;
pub const STATUS_BUFFER_TOO_SMALL: u32 = 5;
pub const CMD_DESIP: u32 = 0;
pub const CMD_DESPORT: u32 = 1;
pub const CMD_CHGDESIPANDPORT: u32 = 2;
pub const CMD_SRCPORT: u32 = 2;
pub const CMD_TCP_TYPE: u32 = 4;
pub const TCP_CLIENT: u32 = 0;
pub const TCP_SERVER: u32 = 1;
pub const CMD_CLIENT_COUNT: u32 = 5;
pub const CMD_CLIENT: u32 = 6;
pub const CMD_DISCONN_CLINET: u32 = 7;
pub const CMD_SET_RECONNECT_TIME: u32 = 8;
pub const TYPE_CAN: u32 = 0;
pub const TYPE_CANFD: u32 = 1;
pub const TYPE_ALL_DATA: u32 = 2;
pub const ZCLOUD_MAX_DEVICES: u32 = 100;
pub const ZCLOUD_MAX_CHANNEL: u32 = 16;
pub const ZCAN_UDS_TRANS_VER_0: u32 = 0;
pub const ZCAN_UDS_TRANS_VER_1: u32 = 1;
pub const ZCAN_UDS_FRAME_CAN: u32 = 0;
pub const ZCAN_UDS_FRAME_CANFD: u32 = 1;
pub const ZCAN_UDS_FRAME_CANFD_BRS: u32 = 2;
pub const ZCAN_UDS_ERROR_OK: u32 = 0;
pub const ZCAN_UDS_ERROR_TIMEOUT: u32 = 1;
pub const ZCAN_UDS_ERROR_TRANSPORT: u32 = 2;
pub const ZCAN_UDS_ERROR_CANCEL: u32 = 3;
pub const ZCAN_UDS_ERROR_SUPPRESS_RESPONSE: u32 = 4;
pub const ZCAN_UDS_ERROR_BUSY: u32 = 5;
pub const ZCAN_UDS_ERROR_REQ_PARAM: u32 = 6;
pub const ZCAN_UDS_ERROR_OTHTER: u32 = 100;
pub const ZCAN_UDS_RT_NEGATIVE: u32 = 0;
pub const ZCAN_UDS_RT_POSITIVE: u32 = 1;
pub const ZCAN_UDS_CTRL_STOP_REQ: u32 = 0;
pub const ZCAN_UDS_CTRL_RESULT_OK: u32 = 0;
pub const ZCAN_UDS_CTRL_RESULT_ERR: u32 = 1;
pub const INVALID_DEVICE_HANDLE: u32 = 0;
pub const INVALID_CHANNEL_HANDLE: u32 = 0;
pub const MAX_DEVICE_COUNT: u32 = 32;
pub const DEVICE_CAN_CHNL_COUNT_MAX: u32 = 8;
pub const DEVICE_LIN_CHNL_COUNT_MAX: u32 = 4;
pub const DEVICE_TOTAL_CHNL_COUNT: u32 = 12;
pub const FILTER_RULE_COUNT_MAX: u32 = 64;
pub const DEV_AUTO_SEND_INDEX_MAX: u32 = 32;
pub const SETREF_SET_CONTROLLER_TYPE: u32 = 1;
pub const SETREF_ADD_FILTER: u32 = 2;
pub const SETREF_APPLY_FILTER: u32 = 3;
pub const SETREF_CLEAR_FILTER: u32 = 4;
pub const SETREF_UPDATE_FIRMWARE: u32 = 5;
pub const GETREF_GET_UPDATE_STATUS: u32 = 6;
pub const SETREF_ADD_TIMER_SEND_CAN: u32 = 7;
pub const SETREF_ADD_TIMER_SEND_CANFD: u32 = 8;
pub const SETREF_APPLY_TIMER_SEND: u32 = 9;
pub const SETREF_CLEAR_TIMER_SEND: u32 = 10;
pub const SETREF_ENABLE_INTERNAL_RESISTANCE: u32 = 11;
pub const SETREF_SET_DEVICE_NAME: u32 = 12;
pub const GETREF_GET_DEVICE_NAME: u32 = 13;
pub const SETREF_CLEAR_DEVICE_LOG: u32 = 14;
pub const GETREF_GET_DEVICE_LOG_SIZE: u32 = 15;
pub const GETREF_GET_DEVICE_LOG_DATA: u32 = 16;
pub const SETREF_SET_DATA_RECV_MERGE: u32 = 17;
pub const GETREF_GET_DATA_RECV_MERGE: u32 = 18;
pub const SETREF_INTERNAL_TEST: u32 = 19;
pub const SETREF_VIRIFY_DEVICE_BY_PASS: u32 = 20;
pub const SETREF_ENABLE_BUS_USAGE: u32 = 21;
pub const SETREF_SET_BUS_USAGE_PERIOD: u32 = 22;
pub const GETREF_GET_BUS_USAGE: u32 = 23;
pub const GETREF_GET_DELAY_SEND_AVALIABLE_COUNT: u32 = 24;
pub const SETREF_CLEAR_DELAY_SEND_QUEUE: u32 = 25;
pub const GETREF_GET_LIN_TX_FIFO_TOTAL: u32 = 26;
pub const GETREF_GET_LIN_TX_FIFO_AVAILABLE: u32 = 27;
pub const SETREF_ADD_TIMER_SEND_CAN_DIRECT: u32 = 28;
pub const SETREF_ADD_TIMER_SEND_CANFD_DIRECT: u32 = 29;
pub const GETREF_GET_DEV_CAN_AUTO_SEND_COUNT: u32 = 30;
pub const GETREF_GET_DEV_CAN_AUTO_SEND_DATA: u32 = 31;
pub const GETREF_GET_DEV_CANFD_AUTO_SEND_COUNT: u32 = 32;
pub const GETREF_GET_DEV_CANFD_AUTO_SEND_DATA: u32 = 33;
pub const SETREF_SET_TX_ECHO: u32 = 34;
pub const GETREF_GET_TX_ECHO: u32 = 35;
pub const USBCANFD_SETREF_SET_TX_RETRY_POLICY: u32 = 36;
pub const SETREF_SET_TX_TIMEOUT: u32 = 37;
pub const SETREF_GET_TX_TIMEOUT: u32 = 38;
pub type va_list = *mut ::core::ffi::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::core::ffi::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::core::ffi::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::core::ffi::c_schar;
pub type int_least16_t = ::core::ffi::c_short;
pub type int_least32_t = ::core::ffi::c_int;
pub type int_least64_t = ::core::ffi::c_longlong;
pub type uint_least8_t = ::core::ffi::c_uchar;
pub type uint_least16_t = ::core::ffi::c_ushort;
pub type uint_least32_t = ::core::ffi::c_uint;
pub type uint_least64_t = ::core::ffi::c_ulonglong;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_int;
pub type int_fast32_t = ::core::ffi::c_int;
pub type int_fast64_t = ::core::ffi::c_longlong;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_uint;
pub type uint_fast32_t = ::core::ffi::c_uint;
pub type uint_fast64_t = ::core::ffi::c_ulonglong;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::core::ffi::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::core::ffi::c_int;
pub type wint_t = ::core::ffi::c_ushort;
pub type wctype_t = ::core::ffi::c_ushort;
pub type __time32_t = ::core::ffi::c_long;
pub type __time64_t = ::core::ffi::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::core::ffi::c_ushort,
    pub _locale_mb_cur_max: ::core::ffi::c_int,
    pub _locale_lc_codepage: ::core::ffi::c_uint,
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::core::ffi::c_ulong,
    pub _Byte: ::core::ffi::c_ushort,
    pub _State: ::core::ffi::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::core::ffi::c_int,
    pub tm_min: ::core::ffi::c_int,
    pub tm_hour: ::core::ffi::c_int,
    pub tm_mday: ::core::ffi::c_int,
    pub tm_mon: ::core::ffi::c_int,
    pub tm_year: ::core::ffi::c_int,
    pub tm_wday: ::core::ffi::c_int,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_int,
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut wchar_t;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut wchar_t, _SizeInWords: usize, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime32_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime64_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
pub type clock_t = ::core::ffi::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::core::ffi::c_long,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::core::ffi::c_long,
}
extern "C" {
    pub fn __daylight() -> *mut ::core::ffi::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::core::ffi::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::core::ffi::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::core::ffi::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::core::ffi::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::core::ffi::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut usize,
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Index: ::core::ffi::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::core::ffi::c_char,
        _SizeInBytes: usize,
        _Format: *const ::core::ffi::c_char,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::core::ffi::c_char,
        _MaxSize: usize,
        _Format: *const ::core::ffi::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::core::ffi::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::core::ffi::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(_Ts: *mut _timespec32, _Base: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _timespec64_get(_Ts: *mut _timespec64, _Base: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn _setsystime(_Tm: *mut tm, _Milliseconds: ::core::ffi::c_uint) -> ::core::ffi::c_uint;
}
extern "C" {
    pub fn tzset();
}
pub type BYTE = ::core::ffi::c_uchar;
pub type UINT = ::core::ffi::c_uint;
pub type ULONG = ::core::ffi::c_ulong;
pub type UINT64 = ::core::ffi::c_ulonglong;
pub type USHORT = ::core::ffi::c_ushort;
pub type UCHAR = ::core::ffi::c_uchar;
pub type canid_t = UINT;
pub type can_err_mask_t = UINT;
#[doc = " struct can_frame - basic CAN frame structure\n @can_id:  CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition\n @can_dlc: frame payload length in byte (0 .. 8) aka data length code\n           N.B. the DLC field from ISO 11898-1 Chapter 8.4.2.3 has a 1:1\n           mapping of the 'data length code' to the real payload length\n @__pad:   padding\n @__res0:  reserved / padding\n @__res1:  reserved / padding\n @data:    CAN frame payload (up to 8 byte)"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct can_frame {
    pub can_id: canid_t,
    pub can_dlc: BYTE,
    pub __pad: BYTE,
    pub __res0: BYTE,
    pub __res1: BYTE,
    pub data: [BYTE; 8usize],
}
#[doc = " struct canfd_frame - CAN flexible data rate frame structure\n @can_id: CAN ID of the frame and CAN_*_FLAG flags, see canid_t definition\n @len:    frame payload length in byte (0 .. CANFD_MAX_DLEN)\n @flags:  additional flags for CAN FD\n @__res0: reserved / padding\n @__res1: reserved / padding\n @data:   CAN FD frame payload (up to CANFD_MAX_DLEN byte)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct canfd_frame {
    pub can_id: canid_t,
    pub len: BYTE,
    pub flags: BYTE,
    pub __res0: BYTE,
    pub __res1: BYTE,
    pub data: [BYTE; 64usize],
}
impl Default for canfd_frame {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Meta\n �ڵ�mata��Ϣ��"]
pub type Meta = _Meta;
#[doc = "  \\struct Pair\n  ���Ե�KeyValue�ԡ�"]
pub type Pair = _Pair;
#[doc = "  \\struct Options\n �ڵ�mata�Ŀ�ѡ�\u{e863}"]
pub type Options = _Options;
#[doc = "  \\struct ConfigNode\n  ConfigNode"]
pub type ConfigNode = _ConfigNode;
#[doc = "  \\struct Options\n �ڵ�mata�Ŀ�ѡ�\u{e863}"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Options {
    #[doc = " ��ѡ�����������"]
    pub type_: *const ::core::ffi::c_char,
    #[doc = " ��ѡ���\u{5b5}"]
    pub value: *const ::core::ffi::c_char,
    #[doc = " ��ѡ���������Ϣ"]
    pub desc: *const ::core::ffi::c_char,
}
impl Default for _Options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Meta\n �ڵ�mata��Ϣ��"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Meta {
    #[doc = " ���������������"]
    pub type_: *const ::core::ffi::c_char,
    #[doc = " �������˵������Ϣ"]
    pub desc: *const ::core::ffi::c_char,
    #[doc = " �������Ƿ���\u{5bb}���ģ�ȱʡΪ�ɶ�д"]
    pub read_only: ::core::ffi::c_int,
    #[doc = " �����������ʽ����ʾ"]
    pub format: *const ::core::ffi::c_char,
    #[doc = " ������\u{5b5}���͵���������˵����С\u{5b5}�����\u{5b7}�������������˵����С���ȣ��\u{5bd}�������"]
    pub min_value: f64,
    #[doc = " ������\u{5b5}���͵���������˵�����\u{5b5}�����\u{5b7}�������������˵����\u{f3936}ȣ��\u{5bd}�������"]
    pub max_value: f64,
    #[doc = " ������ĵ�λ"]
    pub unit: *const ::core::ffi::c_char,
    #[doc = " \u{368}����ť/���\u{5b5}ȷ�ʽ�\u{7b8}�������ʱ������"]
    pub delta: f64,
    #[doc = " �������Ƿ�ɼ�, true�ɼ���false���ɼ���Ҳ���\u{530}\u{f6a31}���ʽ������ʽʹ�òο�demo3����ȱʡ�ɼ�"]
    pub visible: *const ::core::ffi::c_char,
    #[doc = " ���������Ƿ�ʹ��, trueʹ�ܣ�false��ʹ�ܣ�Ҳ���\u{530}\u{f6a31}���ʽ������ʽʹ�òο�demo3����ȱʡʹ��"]
    pub enable: *const ::core::ffi::c_char,
    #[doc = " ������Ŀ�ѡ\u{5b5}��������type��Ϊ�������ʱ��Ч"]
    pub editable: ::core::ffi::c_int,
    #[doc = " ������Ŀ�ѡ\u{5b5}��������type��Ϊ�������ʱ��Ч����NULL����"]
    pub options: *mut *mut Options,
}
impl Default for _Meta {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct Pair\n  ���Ե�KeyValue�ԡ�"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Pair {
    pub key: *const ::core::ffi::c_char,
    pub value: *const ::core::ffi::c_char,
}
impl Default for _Pair {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  \\struct ConfigNode\n  ConfigNode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ConfigNode {
    #[doc = " �ڵ������"]
    pub name: *const ::core::ffi::c_char,
    #[doc = " �ڵ��\u{5b5} \u{36c}�����\u{530}\u{f6a31}���ʽ"]
    pub value: *const ::core::ffi::c_char,
    #[doc = " �ڵ�\u{5b5}�ı���ʽ�����иñ���ʽʱ��value�ɴ˱���ʽ�������"]
    pub binding_value: *const ::core::ffi::c_char,
    #[doc = " �ýڵ��·��"]
    pub path: *const ::core::ffi::c_char,
    #[doc = " ��������Ϣ"]
    pub meta_info: *mut Meta,
    #[doc = " �ýڵ���ӽڵ�, ��NULL����"]
    pub children: *mut *mut ConfigNode,
    #[doc = " �ýڵ������, ��NULL����"]
    pub attributes: *mut *mut Pair,
}
impl Default for _ConfigNode {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief ��ȡ���Ե�������Ϣ��\n\n \\retval ConfigNode"]
pub type GetPropertysFunc = ::core::option::Option<unsafe extern "C" fn() -> *const ConfigNode>;
#[doc = " \\brief ����\u{5b8}��·�������Ե�\u{5b5}��\n \\param[in] path  : ���Ե�·����\n \\param[in] value : ���Ե�\u{5b5}��\n\n \\retval �ɹ�����1��ʧ�\u{737}���0��"]
pub type SetValueFunc = ::core::option::Option<
    unsafe extern "C" fn(
        path: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int,
>;
#[doc = " \\brief ��ȡ\u{5b8}��·�������Ե�\u{5b5}��\n \\param[in] path  : ���Ե�·����\n \\retval �ɹ��������Ե�\u{5b5}��ʧ�\u{737}���NULL��"]
pub type GetValueFunc = ::core::option::Option<
    unsafe extern "C" fn(path: *const ::core::ffi::c_char) -> *const ::core::ffi::c_char,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagIProperty {
    pub SetValue: SetValueFunc,
    pub GetValue: GetValueFunc,
    pub GetPropertys: GetPropertysFunc,
}
pub type IProperty = tagIProperty;
pub type ZCAN_RET_STATUS = UINT;
pub type DEVICE_HANDLE = *mut ::core::ffi::c_void;
pub type CHANNEL_HANDLE = *mut ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_DEVICE_INFO {
    pub hw_Version: USHORT,
    pub fw_Version: USHORT,
    pub dr_Version: USHORT,
    pub in_Version: USHORT,
    pub irq_Num: USHORT,
    pub can_Num: BYTE,
    pub str_Serial_Num: [UCHAR; 20usize],
    pub str_hw_Type: [UCHAR; 40usize],
    pub reserved: [USHORT; 4usize],
}
impl Default for tagZCAN_DEVICE_INFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_DEVICE_INFO = tagZCAN_DEVICE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG {
    pub can_type: UINT,
    pub __bindgen_anon_1: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1 {
    pub can: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_1,
    pub canfd: tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_1 {
    pub acc_code: UINT,
    pub acc_mask: UINT,
    pub reserved: UINT,
    pub filter: BYTE,
    pub timing0: BYTE,
    pub timing1: BYTE,
    pub mode: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1__bindgen_ty_2 {
    pub acc_code: UINT,
    pub acc_mask: UINT,
    pub abit_timing: UINT,
    pub dbit_timing: UINT,
    pub brp: UINT,
    pub filter: BYTE,
    pub mode: BYTE,
    pub pad: USHORT,
    pub reserved: UINT,
}
impl Default for tagZCAN_CHANNEL_INIT_CONFIG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCAN_CHANNEL_INIT_CONFIG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_CHANNEL_INIT_CONFIG = tagZCAN_CHANNEL_INIT_CONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_ERR_INFO {
    pub error_code: UINT,
    pub passive_ErrData: [BYTE; 3usize],
    pub arLost_ErrData: BYTE,
}
pub type ZCAN_CHANNEL_ERR_INFO = tagZCAN_CHANNEL_ERR_INFO;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_CHANNEL_STATUS {
    pub errInterrupt: BYTE,
    pub regMode: BYTE,
    pub regStatus: BYTE,
    pub regALCapture: BYTE,
    pub regECCapture: BYTE,
    pub regEWLimit: BYTE,
    pub regRECounter: BYTE,
    pub regTECounter: BYTE,
    pub Reserved: UINT,
}
pub type ZCAN_CHANNEL_STATUS = tagZCAN_CHANNEL_STATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_Transmit_Data {
    pub frame: can_frame,
    pub transmit_type: UINT,
}
pub type ZCAN_Transmit_Data = tagZCAN_Transmit_Data;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_Receive_Data {
    pub frame: can_frame,
    pub timestamp: UINT64,
}
pub type ZCAN_Receive_Data = tagZCAN_Receive_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_TransmitFD_Data {
    pub frame: canfd_frame,
    pub transmit_type: UINT,
}
impl Default for tagZCAN_TransmitFD_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_TransmitFD_Data = tagZCAN_TransmitFD_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCAN_ReceiveFD_Data {
    pub frame: canfd_frame,
    pub timestamp: UINT64,
}
impl Default for tagZCAN_ReceiveFD_Data {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_ReceiveFD_Data = tagZCAN_ReceiveFD_Data;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_AUTO_TRANSMIT_OBJ {
    pub enable: USHORT,
    pub index: USHORT,
    pub interval: UINT,
    pub obj: ZCAN_Transmit_Data,
}
pub type ZCAN_AUTO_TRANSMIT_OBJ = tagZCAN_AUTO_TRANSMIT_OBJ;
pub type PZCAN_AUTO_TRANSMIT_OBJ = *mut tagZCAN_AUTO_TRANSMIT_OBJ;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCANFD_AUTO_TRANSMIT_OBJ {
    pub enable: USHORT,
    pub index: USHORT,
    pub interval: UINT,
    pub obj: ZCAN_TransmitFD_Data,
}
impl Default for tagZCANFD_AUTO_TRANSMIT_OBJ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANFD_AUTO_TRANSMIT_OBJ = tagZCANFD_AUTO_TRANSMIT_OBJ;
pub type PZCANFD_AUTO_TRANSMIT_OBJ = *mut tagZCANFD_AUTO_TRANSMIT_OBJ;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCAN_AUTO_TRANSMIT_OBJ_PARAM {
    pub index: USHORT,
    pub type_: USHORT,
    pub value: UINT,
}
pub type ZCAN_AUTO_TRANSMIT_OBJ_PARAM = tagZCAN_AUTO_TRANSMIT_OBJ_PARAM;
pub type PZCAN_AUTO_TRANSMIT_OBJ_PARAM = *mut tagZCAN_AUTO_TRANSMIT_OBJ_PARAM;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCLOUD_CHNINFO {
    pub enable: BYTE,
    pub type_: BYTE,
    pub isUpload: BYTE,
    pub isDownload: BYTE,
}
pub type ZCLOUD_CHNINFO = tagZCLOUD_CHNINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCLOUD_DEVINFO {
    pub devIndex: ::core::ffi::c_int,
    pub type_: [::core::ffi::c_char; 64usize],
    pub id: [::core::ffi::c_char; 64usize],
    pub name: [::core::ffi::c_char; 64usize],
    pub owner: [::core::ffi::c_char; 64usize],
    pub model: [::core::ffi::c_char; 64usize],
    pub fwVer: [::core::ffi::c_char; 16usize],
    pub hwVer: [::core::ffi::c_char; 16usize],
    pub serial: [::core::ffi::c_char; 64usize],
    pub status: ::core::ffi::c_int,
    pub bGpsUpload: BYTE,
    pub channelCnt: BYTE,
    pub channels: [ZCLOUD_CHNINFO; 16usize],
}
impl Default for tagZCLOUD_DEVINFO {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCLOUD_DEVINFO = tagZCLOUD_DEVINFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagZCLOUD_USER_DATA {
    pub username: [::core::ffi::c_char; 64usize],
    pub mobile: [::core::ffi::c_char; 64usize],
    pub dllVer: [::core::ffi::c_char; 16usize],
    pub devCnt: usize,
    pub devices: [ZCLOUD_DEVINFO; 100usize],
}
impl Default for tagZCLOUD_USER_DATA {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCLOUD_USER_DATA = tagZCLOUD_USER_DATA;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCLOUD_GPS_FRAME {
    pub latitude: f32,
    pub longitude: f32,
    pub speed: f32,
    pub tm: tagZCLOUD_GPS_FRAME___gps_time,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCLOUD_GPS_FRAME___gps_time {
    pub year: USHORT,
    pub mon: USHORT,
    pub day: USHORT,
    pub hour: USHORT,
    pub min: USHORT,
    pub sec: USHORT,
}
pub type ZCLOUD_GPS_FRAME = tagZCLOUD_GPS_FRAME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagUSBCANFDTxTimeStamp {
    pub pTxTimeStampBuffer: *mut UINT,
    pub nBufferTimeStampCount: UINT,
}
impl Default for tagUSBCANFDTxTimeStamp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type USBCANFDTxTimeStamp = tagUSBCANFDTxTimeStamp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagTxTimeStamp {
    pub pTxTimeStampBuffer: *mut UINT64,
    pub nBufferTimeStampCount: UINT,
    pub nWaitTime: ::core::ffi::c_int,
}
impl Default for tagTxTimeStamp {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type TxTimeStamp = tagTxTimeStamp;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagBusUsage {
    pub nTimeStampBegin: UINT64,
    pub nTimeStampEnd: UINT64,
    pub nChnl: BYTE,
    pub nReserved: BYTE,
    pub nBusUsage: USHORT,
    pub nFrameCount: UINT,
}
pub type BusUsage = tagBusUsage;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_NO_ERR: eZCANErrorDEF = 0;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_BUS_ERR: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_CONTROLLER_ERR: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_ERR_TYPE_DEVICE_ERR: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_ACTIVE: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_WARNNING: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_PASSIVE: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_NODE_STATE_BUSOFF: eZCANErrorDEF = 4;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_NO_ERR: eZCANErrorDEF = 0;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_BIT_ERR: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_ACK_ERR: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_CRC_ERR: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_FORM_ERR: eZCANErrorDEF = 4;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_STUFF_ERR: eZCANErrorDEF = 5;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_OVERLOAD_ERR: eZCANErrorDEF = 6;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_ARBITRATION_LOST: eZCANErrorDEF = 7;
pub const eZCANErrorDEF_ZCAN_BUS_ERR_NODE_STATE_CHAGE: eZCANErrorDEF = 8;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_RX_FIFO_OVERFLOW: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_DRIVER_RX_BUFFER_OVERFLOW: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_DRIVER_TX_BUFFER_OVERFLOW: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_INTERNAL_ERROR: eZCANErrorDEF = 4;
pub const eZCANErrorDEF_ZCAN_DEVICE_APP_RX_BUFFER_OVERFLOW: eZCANErrorDEF = 1;
pub const eZCANErrorDEF_ZCAN_DEVICE_APP_TX_BUFFER_OVERFLOW: eZCANErrorDEF = 2;
pub const eZCANErrorDEF_ZCAN_DEVICE_APP_AUTO_SEND_FAILED: eZCANErrorDEF = 3;
pub const eZCANErrorDEF_ZCAN_CONTROLLER_TX_FRAME_INVALID: eZCANErrorDEF = 4;
pub type eZCANErrorDEF = ::core::ffi::c_int;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_CAN_CANFD_DATA: eZCANDataDEF = 1;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_ERROR_DATA: eZCANDataDEF = 2;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_GPS_DATA: eZCANDataDEF = 3;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_DATA: eZCANDataDEF = 4;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_BUSUSAGE_DATA: eZCANDataDEF = 5;
pub const eZCANDataDEF_ZCAN_DT_ZCAN_LIN_ERROR_DATA: eZCANDataDEF = 6;
pub const eZCANDataDEF_ZCAN_TX_DELAY_NO_DELAY: eZCANDataDEF = 0;
pub const eZCANDataDEF_ZCAN_TX_DELAY_UNIT_MS: eZCANDataDEF = 1;
pub const eZCANDataDEF_ZCAN_TX_DELAY_UNIT_100US: eZCANDataDEF = 2;
pub type eZCANDataDEF = ::core::ffi::c_int;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANCANFDData {
    pub timeStamp: UINT64,
    pub flag: tagZCANCANFDData__bindgen_ty_1,
    pub extraData: [BYTE; 4usize],
    pub frame: canfd_frame,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANCANFDData__bindgen_ty_1 {
    pub unionVal: tagZCANCANFDData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: UINT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANCANFDData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl tagZCANCANFDData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn frameType(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_frameType(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn txDelay(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_txDelay(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn transmitType(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_transmitType(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn txEchoRequest(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txEchoRequest(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn txEchoed(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_txEchoed(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> UINT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: UINT) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frameType: UINT,
        txDelay: UINT,
        transmitType: UINT,
        txEchoRequest: UINT,
        txEchoed: UINT,
        reserved: UINT,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let frameType: u32 = unsafe { ::core::mem::transmute(frameType) };
            frameType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let txDelay: u32 = unsafe { ::core::mem::transmute(txDelay) };
            txDelay as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let transmitType: u32 = unsafe { ::core::mem::transmute(transmitType) };
            transmitType as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let txEchoRequest: u32 = unsafe { ::core::mem::transmute(txEchoRequest) };
            txEchoRequest as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let txEchoed: u32 = unsafe { ::core::mem::transmute(txEchoed) };
            txEchoed as u64
        });
        __bindgen_bitfield_unit.set(10usize, 22u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANCANFDData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANCANFDData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANCANFDData = tagZCANCANFDData;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANErrorData {
    pub timeStamp: UINT64,
    pub errType: BYTE,
    pub errSubType: BYTE,
    pub nodeState: BYTE,
    pub rxErrCount: BYTE,
    pub txErrCount: BYTE,
    pub errData: BYTE,
    pub reserved: [BYTE; 2usize],
}
pub type ZCANErrorData = tagZCANErrorData;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANGPSData {
    pub time: tagZCANGPSData__bindgen_ty_1,
    pub flag: tagZCANGPSData__bindgen_ty_2,
    pub latitude: f64,
    pub longitude: f64,
    pub altitude: f64,
    pub speed: f64,
    pub courseAngle: f64,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANGPSData__bindgen_ty_1 {
    pub year: USHORT,
    pub mon: USHORT,
    pub day: USHORT,
    pub hour: USHORT,
    pub min: USHORT,
    pub sec: USHORT,
    pub milsec: USHORT,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANGPSData__bindgen_ty_2 {
    pub unionVal: tagZCANGPSData__bindgen_ty_2__bindgen_ty_1,
    pub rawVal: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANGPSData__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
impl tagZCANGPSData__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn timeValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_timeValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn latlongValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_latlongValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn altitudeValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_altitudeValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn speedValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_speedValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn courseAngleValid(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_courseAngleValid(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        timeValid: USHORT,
        latlongValid: USHORT,
        altitudeValid: USHORT,
        speedValid: USHORT,
        courseAngleValid: USHORT,
        reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let timeValid: u16 = unsafe { ::core::mem::transmute(timeValid) };
            timeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let latlongValid: u16 = unsafe { ::core::mem::transmute(latlongValid) };
            latlongValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let altitudeValid: u16 = unsafe { ::core::mem::transmute(altitudeValid) };
            altitudeValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let speedValid: u16 = unsafe { ::core::mem::transmute(speedValid) };
            speedValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let courseAngleValid: u16 = unsafe { ::core::mem::transmute(courseAngleValid) };
            courseAngleValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 13u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANGPSData__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANGPSData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANGPSData = tagZCANGPSData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCANLINData {
    pub PID: tagZCANLINData__bindgen_ty_1,
    pub RxData: tagZCANLINData__bindgen_ty_2,
    pub reserved: [BYTE; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANLINData__bindgen_ty_1 {
    pub unionVal: tagZCANLINData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tagZCANLINData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Parity(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Parity(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: BYTE, Parity: BYTE) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Parity: u8 = unsafe { ::core::mem::transmute(Parity) };
            Parity as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINData__bindgen_ty_2 {
    pub timeStamp: UINT64,
    pub dataLen: BYTE,
    pub dir: BYTE,
    pub chkSum: BYTE,
    pub reserved: [BYTE; 13usize],
    pub data: [BYTE; 8usize],
}
impl Default for tagZCANLINData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINData = tagZCANLINData;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct tagZCANLINErrData {
    pub timeStamp: UINT64,
    pub PID: tagZCANLINErrData__bindgen_ty_1,
    pub dataLen: BYTE,
    pub data: [BYTE; 8usize],
    pub errData: tagZCANLINErrData__bindgen_ty_2,
    pub dir: BYTE,
    pub chkSum: BYTE,
    pub reserved: [BYTE; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tagZCANLINErrData__bindgen_ty_1 {
    pub unionVal: tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: BYTE,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl tagZCANLINErrData__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn Parity(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_Parity(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: BYTE, Parity: BYTE) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let Parity: u8 = unsafe { ::core::mem::transmute(Parity) };
            Parity as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINErrData__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANLINErrData__bindgen_ty_2 {
    pub __bindgen_anon_1: tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1,
    pub unionErrData: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tagZCANLINErrData__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn errStage(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_errStage(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn errReason(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_errReason(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        errStage: USHORT,
        errReason: USHORT,
        reserved: USHORT,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let errStage: u16 = unsafe { ::core::mem::transmute(errStage) };
            errStage as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let errReason: u16 = unsafe { ::core::mem::transmute(errReason) };
            errReason as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANLINErrData__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANLINErrData {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANLINErrData = tagZCANLINErrData;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tagZCANDataObj {
    pub dataType: BYTE,
    pub chnl: BYTE,
    pub flag: tagZCANDataObj__bindgen_ty_1,
    pub extraData: [BYTE; 4usize],
    pub data: tagZCANDataObj__bindgen_ty_2,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANDataObj__bindgen_ty_1 {
    pub unionVal: tagZCANDataObj__bindgen_ty_1__bindgen_ty_1,
    pub rawVal: USHORT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagZCANDataObj__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl tagZCANDataObj__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn reserved(&self) -> USHORT {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: USHORT) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved: USHORT) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let reserved: u16 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for tagZCANDataObj__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union tagZCANDataObj__bindgen_ty_2 {
    pub zcanCANFDData: ZCANCANFDData,
    pub zcanErrData: ZCANErrorData,
    pub zcanGPSData: ZCANGPSData,
    pub zcanLINData: ZCANLINData,
    pub zcanLINErrData: ZCANLINErrData,
    pub busUsage: BusUsage,
    pub raw: [BYTE; 92usize],
}
impl Default for tagZCANDataObj__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for tagZCANDataObj {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCANDataObj = tagZCANDataObj;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _VCI_LIN_MSG {
    pub chnl: BYTE,
    pub dataType: BYTE,
    pub data: _VCI_LIN_MSG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _VCI_LIN_MSG__bindgen_ty_1 {
    pub zcanLINData: ZCANLINData,
    pub zcanLINErrData: ZCANLINErrData,
    pub raw: [BYTE; 46usize],
}
impl Default for _VCI_LIN_MSG__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _VCI_LIN_MSG {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_LIN_MSG = _VCI_LIN_MSG;
pub type PZCAN_LIN_MSG = *mut _VCI_LIN_MSG;
pub const eZLINChkSumMode_DEFAULT: eZLINChkSumMode = 0;
pub const eZLINChkSumMode_CLASSIC_CHKSUM: eZLINChkSumMode = 1;
pub const eZLINChkSumMode_ENHANCE_CHKSUM: eZLINChkSumMode = 2;
pub const eZLINChkSumMode_AUTOMATIC: eZLINChkSumMode = 3;
pub type eZLINChkSumMode = ::core::ffi::c_int;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_INIT_CONFIG {
    pub linMode: BYTE,
    pub chkSumMode: BYTE,
    pub reserved: USHORT,
    pub linBaud: UINT,
}
pub type ZCAN_LIN_INIT_CONFIG = _VCI_LIN_INIT_CONFIG;
pub type PZCAN_LIN_INIT_CONFIG = *mut _VCI_LIN_INIT_CONFIG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_PUBLISH_CFG {
    pub ID: BYTE,
    pub dataLen: BYTE,
    pub data: [BYTE; 8usize],
    pub chkSumMode: BYTE,
    pub reserved: [BYTE; 5usize],
}
pub type ZCAN_LIN_PUBLISH_CFG = _VCI_LIN_PUBLISH_CFG;
pub type PZCAN_LIN_PUBLISH_CFG = *mut _VCI_LIN_PUBLISH_CFG;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _VCI_LIN_SUBSCIBE_CFG {
    pub ID: BYTE,
    pub dataLen: BYTE,
    pub chkSumMode: BYTE,
    pub reserved: [BYTE; 5usize],
}
pub type ZCAN_LIN_SUBSCIBE_CFG = _VCI_LIN_SUBSCIBE_CFG;
pub type PZCAN_LIN_SUBSCIBE_CFG = *mut _VCI_LIN_SUBSCIBE_CFG;
pub type ZCAN_UDS_TRANS_VER = BYTE;
pub type ZCAN_UDS_FRAME_TYPE = BYTE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST {
    pub req_id: UINT,
    pub channel: BYTE,
    pub frame_type: ZCAN_UDS_FRAME_TYPE,
    pub reserved0: [BYTE; 2usize],
    pub src_addr: UINT,
    pub dst_addr: UINT,
    pub suppress_response: BYTE,
    pub sid: BYTE,
    pub reserved1: [BYTE; 6usize],
    pub session_param: _ZCAN_UDS_REQUEST__bindgen_ty_1,
    pub trans_param: _ZCAN_UDS_REQUEST__bindgen_ty_2,
    pub data: *mut BYTE,
    pub data_len: UINT,
    pub reserved2: UINT,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST__bindgen_ty_1 {
    pub timeout: UINT,
    pub enhanced_timeout: UINT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved0: [BYTE; 7usize],
}
impl _ZCAN_UDS_REQUEST__bindgen_ty_1 {
    #[inline]
    pub fn check_any_negative_response(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_check_any_negative_response(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_if_suppress_response(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_if_suppress_response(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flag(&self) -> BYTE {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_flag(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        check_any_negative_response: BYTE,
        wait_if_suppress_response: BYTE,
        flag: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let check_any_negative_response: u8 =
                unsafe { ::core::mem::transmute(check_any_negative_response) };
            check_any_negative_response as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let wait_if_suppress_response: u8 =
                unsafe { ::core::mem::transmute(wait_if_suppress_response) };
            wait_if_suppress_response as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let flag: u8 = unsafe { ::core::mem::transmute(flag) };
            flag as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_REQUEST__bindgen_ty_2 {
    pub version: ZCAN_UDS_TRANS_VER,
    pub max_data_len: BYTE,
    pub local_st_min: BYTE,
    pub block_size: BYTE,
    pub fill_byte: BYTE,
    pub ext_frame: BYTE,
    pub is_modify_ecu_st_min: BYTE,
    pub remote_st_min: BYTE,
    pub fc_timeout: UINT,
    pub reserved0: [BYTE; 4usize],
}
impl Default for _ZCAN_UDS_REQUEST {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_UDS_REQUEST = _ZCAN_UDS_REQUEST;
pub type ZCAN_UDS_ERROR = BYTE;
pub type ZCAN_UDS_RESPONSE_TYPE = BYTE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE {
    pub status: ZCAN_UDS_ERROR,
    pub reserved: [BYTE; 6usize],
    pub type_: ZCAN_UDS_RESPONSE_TYPE,
    pub __bindgen_anon_1: _ZCAN_UDS_RESPONSE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ZCAN_UDS_RESPONSE__bindgen_ty_1 {
    pub positive: _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_1,
    pub negative: _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_2,
    pub raw: [BYTE; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_1 {
    pub sid: BYTE,
    pub data_len: UINT,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_RESPONSE__bindgen_ty_1__bindgen_ty_2 {
    pub neg_code: BYTE,
    pub sid: BYTE,
    pub error_code: BYTE,
}
impl Default for _ZCAN_UDS_RESPONSE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _ZCAN_UDS_RESPONSE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ZCAN_UDS_RESPONSE = _ZCAN_UDS_RESPONSE;
pub type ZCAN_UDS_CTRL_CODE = UINT;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_CTRL_REQ {
    pub reqID: UINT,
    pub cmd: ZCAN_UDS_CTRL_CODE,
    pub reserved: [BYTE; 8usize],
}
pub type ZCAN_UDS_CTRL_REQ = _ZCAN_UDS_CTRL_REQ;
pub type ZCAN_UDS_CTRL_RESULT = UINT;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ZCAN_UDS_CTRL_RESP {
    pub result: ZCAN_UDS_CTRL_RESULT,
    pub reserved: [BYTE; 8usize],
}
pub type ZCAN_UDS_CTRL_RESP = _ZCAN_UDS_CTRL_RESP;
extern "C" {
    pub fn ZCAN_OpenDevice(device_type: UINT, device_index: UINT, reserved: UINT) -> DEVICE_HANDLE;
}
extern "C" {
    pub fn ZCAN_CloseDevice(device_handle: DEVICE_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetDeviceInf(device_handle: DEVICE_HANDLE, pInfo: *mut ZCAN_DEVICE_INFO) -> UINT;
}
extern "C" {
    pub fn ZCAN_IsDeviceOnLine(device_handle: DEVICE_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_InitCAN(
        device_handle: DEVICE_HANDLE,
        can_index: UINT,
        pInitConfig: *mut ZCAN_CHANNEL_INIT_CONFIG,
    ) -> CHANNEL_HANDLE;
}
extern "C" {
    pub fn ZCAN_StartCAN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ResetCAN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ClearBuffer(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReadChannelErrInfo(
        channel_handle: CHANNEL_HANDLE,
        pErrInfo: *mut ZCAN_CHANNEL_ERR_INFO,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReadChannelStatus(
        channel_handle: CHANNEL_HANDLE,
        pCANStatus: *mut ZCAN_CHANNEL_STATUS,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetReceiveNum(channel_handle: CHANNEL_HANDLE, type_: BYTE) -> UINT;
}
extern "C" {
    pub fn ZCAN_Transmit(
        channel_handle: CHANNEL_HANDLE,
        pTransmit: *mut ZCAN_Transmit_Data,
        len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_Receive(
        channel_handle: CHANNEL_HANDLE,
        pReceive: *mut ZCAN_Receive_Data,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_TransmitFD(
        channel_handle: CHANNEL_HANDLE,
        pTransmit: *mut ZCAN_TransmitFD_Data,
        len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReceiveFD(
        channel_handle: CHANNEL_HANDLE,
        pReceive: *mut ZCAN_ReceiveFD_Data,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_TransmitData(
        device_handle: DEVICE_HANDLE,
        pTransmit: *mut ZCANDataObj,
        len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReceiveData(
        device_handle: DEVICE_HANDLE,
        pReceive: *mut ZCANDataObj,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetValue(
        device_handle: DEVICE_HANDLE,
        path: *const ::core::ffi::c_char,
        value: *const ::core::ffi::c_void,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetValue(
        device_handle: DEVICE_HANDLE,
        path: *const ::core::ffi::c_char,
    ) -> *const ::core::ffi::c_void;
}
extern "C" {
    pub fn GetIProperty(device_handle: DEVICE_HANDLE) -> *mut IProperty;
}
extern "C" {
    pub fn ReleaseIProperty(pIProperty: *mut IProperty) -> UINT;
}
extern "C" {
    pub fn ZCLOUD_SetServerInfo(
        httpSvr: *const ::core::ffi::c_char,
        httpPort: ::core::ffi::c_ushort,
        authSvr: *const ::core::ffi::c_char,
        authPort: ::core::ffi::c_ushort,
    );
}
extern "C" {
    pub fn ZCLOUD_ConnectServer(
        username: *const ::core::ffi::c_char,
        password: *const ::core::ffi::c_char,
    ) -> UINT;
}
extern "C" {
    pub fn ZCLOUD_IsConnected() -> UINT;
}
extern "C" {
    pub fn ZCLOUD_DisconnectServer() -> UINT;
}
extern "C" {
    pub fn ZCLOUD_GetUserData(update: ::core::ffi::c_int) -> *const ZCLOUD_USER_DATA;
}
extern "C" {
    pub fn ZCLOUD_ReceiveGPS(
        device_handle: DEVICE_HANDLE,
        pReceive: *mut ZCLOUD_GPS_FRAME,
        len: UINT,
        wait_time: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_InitLIN(
        device_handle: DEVICE_HANDLE,
        lin_index: UINT,
        pLINInitConfig: PZCAN_LIN_INIT_CONFIG,
    ) -> CHANNEL_HANDLE;
}
extern "C" {
    pub fn ZCAN_StartLIN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ResetLIN(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_TransmitLIN(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_MSG,
        Len: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_GetLINReceiveNum(channel_handle: CHANNEL_HANDLE) -> UINT;
}
extern "C" {
    pub fn ZCAN_ReceiveLIN(
        channel_handle: CHANNEL_HANDLE,
        pReceive: PZCAN_LIN_MSG,
        Len: UINT,
        WaitTime: ::core::ffi::c_int,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetLINSubscribe(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_SUBSCIBE_CFG,
        nSubscribeCount: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetLINPublish(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_PUBLISH_CFG,
        nPublishCount: UINT,
    ) -> UINT;
}
extern "C" {
    #[doc = " @brief UDS�������\n @param[in] device_handle �豸���\n @param[in] req ������Ϣ\n @param[out] resp ��Ӧ��Ϣ, ��Ϊnullptr, ��ʾ��������Ӧ����\n @param[out] dataBuf ��Ӧ���ݻ�����, ��Ż�����Ӧ���������(������SID), ʵ�ʳ���Ϊresp.positive.data_len\n @param[out] dataBufSize ��Ӧ���ݻ������\u{734}�С�����С����Ӧ������ݳ��ȣ����� STATUS_BUFFER_TOO_SMALL\n @return \u{5b4}�н��״\u{32c}"]
    pub fn ZCAN_UDS_Request(
        device_handle: DEVICE_HANDLE,
        req: *const ZCAN_UDS_REQUEST,
        resp: *mut ZCAN_UDS_RESPONSE,
        dataBuf: *mut BYTE,
        dataBufSize: UINT,
    ) -> ZCAN_RET_STATUS;
}
extern "C" {
    #[doc = " @brief UDS��Ͽ���, ��\u{363}\u{5b9}����\u{5b4}�е�UDS����\n @param[in] device_handle �豸���\n @param[in] ctrl ����������Ϣ\n @param[out] resp ��Ӧ��Ϣ, ��Ϊnullptr, ��ʾ��������Ӧ����\n @return \u{5b4}�н��״\u{32c}"]
    pub fn ZCAN_UDS_Control(
        device_handle: DEVICE_HANDLE,
        ctrl: *const ZCAN_UDS_CTRL_REQ,
        resp: *mut ZCAN_UDS_CTRL_RESP,
    ) -> ZCAN_RET_STATUS;
}
extern "C" {
    pub fn ZCAN_SetLINSlaveMsg(
        channel_handle: CHANNEL_HANDLE,
        pSend: PZCAN_LIN_MSG,
        nMsgCount: UINT,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_ClearLINSlaveMsg(
        channel_handle: CHANNEL_HANDLE,
        pLINID: *mut BYTE,
        nIDCount: UINT,
    ) -> UINT;
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct DeviceInfo {
    pub nCANChnl: ::core::ffi::c_int,
    pub nLINChnl: ::core::ffi::c_int,
    pub nDeviceMaxDataLen: u32,
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct RefFilterItem {
    pub nExt: u32,
    pub nBeginID: u32,
    pub nEndID: u32,
}
extern "C" {
    pub fn ZCAN_GetReference(
        DeviceType: UINT,
        nDevIndex: UINT,
        nChnlIndex: UINT,
        nRefType: UINT,
        pData: *mut ::core::ffi::c_void,
    ) -> UINT;
}
extern "C" {
    pub fn ZCAN_SetReference(
        DeviceType: UINT,
        nDevIndex: UINT,
        nChnlIndex: UINT,
        nRefType: UINT,
        pData: *mut ::core::ffi::c_void,
    ) -> UINT;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
